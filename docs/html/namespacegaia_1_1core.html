<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gaia-ECS: gaia::core Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">Gaia-ECS<span id="projectnumber">&#160;v0.9.2</span>
   </div>
   <div id="projectbrief">A simple and powerful entity component system (ECS) written in C++17</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacegaia_1_1core.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">gaia::core Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:bit_5Fview" id="r_bit_5Fview"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1bit__view.html">bit_view</a></td></tr>
<tr class="memitem:dyn_5Fsingleton" id="r_dyn_5Fsingleton"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1core_1_1dyn__singleton.html">dyn_singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gaia-ECS is a header-only library which means we want to avoid using global static variables because they would get copied to each translation units. At the same time the goal is for users to not see any memory allocation used by the library. Therefore, the only solution is a static variable with local scope.  <a href="classgaia_1_1core_1_1dyn__singleton.html#details">More...</a><br /></td></tr>
<tr class="memitem:direct_5Fhash_5Fkey" id="r_direct_5Fhash_5Fkey"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1direct__hash__key.html">direct_hash_key</a></td></tr>
<tr class="memitem:StringLookupKey" id="r_StringLookupKey"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1_string_lookup_key.html">StringLookupKey</a></td></tr>
<tr class="memitem:span" id="r_span"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1core_1_1span.html">span</a></td></tr>
<tr class="memitem:input_5Fiterator_5Ftag" id="r_input_5Fiterator_5Ftag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1input__iterator__tag.html">input_iterator_tag</a></td></tr>
<tr class="memitem:output_5Fiterator_5Ftag" id="r_output_5Fiterator_5Ftag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1output__iterator__tag.html">output_iterator_tag</a></td></tr>
<tr class="memitem:forward_5Fiterator_5Ftag" id="r_forward_5Fiterator_5Ftag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1forward__iterator__tag.html">forward_iterator_tag</a></td></tr>
<tr class="memitem:reverse_5Fiterator_5Ftag" id="r_reverse_5Fiterator_5Ftag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1reverse__iterator__tag.html">reverse_iterator_tag</a></td></tr>
<tr class="memitem:bidirectional_5Fiterator_5Ftag" id="r_bidirectional_5Fiterator_5Ftag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a></td></tr>
<tr class="memitem:random_5Faccess_5Fiterator_5Ftag" id="r_random_5Faccess_5Fiterator_5Ftag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1random__access__iterator__tag.html">random_access_iterator_tag</a></td></tr>
<tr class="memitem:contiguous_5Fiterator_5Ftag" id="r_contiguous_5Fiterator_5Ftag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1contiguous__iterator__tag.html">contiguous_iterator_tag</a></td></tr>
<tr class="memitem:is_5Fiterator" id="r_is_5Fiterator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="memitem:zero_5Ft" id="r_zero_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1zero__t.html">zero_t</a></td></tr>
<tr class="memitem:lock_5Fscope" id="r_lock_5Fscope"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1lock__scope.html">lock_scope</a></td></tr>
<tr class="memitem:has_5Fdata_5Fsize" id="r_has_5Fdata_5Fsize"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1has__data__size.html">has_data_size</a></td></tr>
<tr class="memitem:has_5Fdata_5Fsize_3C_20T_2C_20std_3A_3Avoid_5Ft_3C_20decltype_28detail_3A_3Adata_28std_3A_3Adeclval_3C_20T_20_3E_28_29_29_29_2C_20decltype_28detail_3A_3Asize_28std_3A_3Adeclval_3C_20T_20_3E_28_29_29_29_20_3E_20_3E" id="r_has_5Fdata_5Fsize_3C_20T_2C_20std_3A_3Avoid_5Ft_3C_20decltype_28detail_3A_3Adata_28std_3A_3Adeclval_3C_20T_20_3E_28_29_29_29_2C_20decltype_28detail_3A_3Asize_28std_3A_3Adeclval_3C_20T_20_3E_28_29_29_29_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1has__data__size_3_01_t_00_01std_1_1void__t_3_01decltype_07detail_1_1data_00984fac1ca8d3cbc3e67a677f76b078e.html">has_data_size&lt; T, std::void_t&lt; decltype(detail::data(std::declval&lt; T &gt;())), decltype(detail::size(std::declval&lt; T &gt;())) &gt; &gt;</a></td></tr>
<tr class="memitem:has_5Fsize_5Fbegin_5Fend" id="r_has_5Fsize_5Fbegin_5Fend"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1has__size__begin__end.html">has_size_begin_end</a></td></tr>
<tr class="memitem:has_5Fsize_5Fbegin_5Fend_3C_20T_2C_20std_3A_3Avoid_5Ft_3C_20decltype_28std_3A_3Adeclval_3C_20T_20_3E_28_29_2Ebegin_28_29_29_2C_20decltype_28std_3A_3Adeclval_3C_20T_20_3E_28_29_2Eend_28_29_29_2C_20decltype_28detail_3A_3Asize_28std_3A_3Adeclval_3C_20T_20_3E_28_29_29_29_20_3E_20_3E" id="r_has_5Fsize_5Fbegin_5Fend_3C_20T_2C_20std_3A_3Avoid_5Ft_3C_20decltype_28std_3A_3Adeclval_3C_20T_20_3E_28_29_2Ebegin_28_29_29_2C_20decltype_28std_3A_3Adeclval_3C_20T_20_3E_28_29_2Eend_28_29_29_2C_20decltype_28detail_3A_3Asize_28std_3A_3Adeclval_3C_20T_20_3E_28_29_29_29_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1has__size__begin__end_3_01_t_00_01std_1_1void__t_3_01decltype_07std_1_1dec09b9fa48ac2d7cf23afb1be72b9ea8bd.html">has_size_begin_end&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;().begin()), decltype(std::declval&lt; T &gt;().end()), decltype(detail::size(std::declval&lt; T &gt;())) &gt; &gt;</a></td></tr>
<tr class="memitem:unique" id="r_unique"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1unique.html">unique</a></td></tr>
<tr class="memitem:unique_3C_20std_3A_3Atuple_3C_20Ts_2E_2E_2E_20_3E_2C_20U_2C_20Us_2E_2E_2E_20_3E" id="r_unique_3C_20std_3A_3Atuple_3C_20Ts_2E_2E_2E_20_3E_2C_20U_2C_20Us_2E_2E_2E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1unique_3_01std_1_1tuple_3_01_ts_8_8_8_01_4_00_01_u_00_01_us_8_8_8_01_4.html">unique&lt; std::tuple&lt; Ts... &gt;, U, Us... &gt;</a></td></tr>
<tr class="memitem:func_5Ftype_5Flist" id="r_func_5Ftype_5Flist"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1func__type__list.html">func_type_list</a></td></tr>
<tr class="memitem:has_5Ffunc_5Fequals" id="r_has_5Ffunc_5Fequals"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1has__func__equals.html">has_func_equals</a></td></tr>
<tr class="memitem:has_5Fffunc_5Fequals" id="r_has_5Fffunc_5Fequals"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1has__ffunc__equals.html">has_ffunc_equals</a></td></tr>
<tr class="memitem:type_5Flist" id="r_type_5Flist"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1type__list.html">type_list</a></td></tr>
<tr class="memitem:type_5Flist_5Fconcat" id="r_type_5Flist_5Fconcat"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1type__list__concat.html">type_list_concat</a></td></tr>
<tr class="memitem:type_5Flist_5Fconcat_3C_20type_5Flist_3C_20TypesA_2E_2E_2E_20_3E_2C_20type_5Flist_3C_20TypesB_2E_2E_2E_20_3E_20_3E" id="r_type_5Flist_5Fconcat_3C_20type_5Flist_3C_20TypesA_2E_2E_2E_20_3E_2C_20type_5Flist_3C_20TypesB_2E_2E_2E_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1type__list__concat_3_01type__list_3_01_types_a_8_8_8_01_4_00_01type__list_3_01_types_b_8_8_8_01_4_01_4.html">type_list_concat&lt; type_list&lt; TypesA... &gt;, type_list&lt; TypesB... &gt; &gt;</a></td></tr>
<tr class="memitem:equal_5Fto" id="r_equal_5Fto"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1equal__to.html">equal_to</a></td></tr>
<tr class="memitem:is_5Fsmaller" id="r_is_5Fsmaller"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1is__smaller.html">is_smaller</a></td></tr>
<tr class="memitem:is_5Fsmaller_5For_5Fequal" id="r_is_5Fsmaller_5For_5Fequal"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1is__smaller__or__equal.html">is_smaller_or_equal</a></td></tr>
<tr class="memitem:is_5Fgreater" id="r_is_5Fgreater"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgaia_1_1core_1_1is__greater.html">is_greater</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9e89715681e51c04166214985a1dab56" id="r_a9e89715681e51c04166214985a1dab56"><td class="memItemLeft" align="right" valign="top"><a id="a9e89715681e51c04166214985a1dab56" name="a9e89715681e51c04166214985a1dab56"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>span_diff_type</b> = size_t</td></tr>
<tr class="memitem:a49bde8885f899b3f5dd62a11d01e75d1" id="r_a49bde8885f899b3f5dd62a11d01e75d1"><td class="memItemLeft" align="right" valign="top"><a id="a49bde8885f899b3f5dd62a11d01e75d1" name="a49bde8885f899b3f5dd62a11d01e75d1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>span_size_type</b> = size_t</td></tr>
<tr class="memitem:ac13366d3348a062f8c2c75e0f8c19c84" id="r_ac13366d3348a062f8c2c75e0f8c19c84"><td class="memTemplParams" colspan="2"><a id="ac13366d3348a062f8c2c75e0f8c19c84" name="ac13366d3348a062f8c2c75e0f8c19c84"></a>
template&lt;typename It&gt; </td></tr>
<tr class="memitem:ac13366d3348a062f8c2c75e0f8c19c84 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_ref_t</b> = typename <a class="el" href="structgaia_1_1core_1_1detail_1_1iterator__traits.html">detail::iterator_traits</a>&lt;It&gt;::reference</td></tr>
<tr class="memitem:a13c03a90b93323804767d7e825a12a21" id="r_a13c03a90b93323804767d7e825a12a21"><td class="memTemplParams" colspan="2"><a id="a13c03a90b93323804767d7e825a12a21" name="a13c03a90b93323804767d7e825a12a21"></a>
template&lt;typename It&gt; </td></tr>
<tr class="memitem:a13c03a90b93323804767d7e825a12a21 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_value_t</b> = typename <a class="el" href="structgaia_1_1core_1_1detail_1_1iterator__traits.html">detail::iterator_traits</a>&lt;It&gt;::value_type</td></tr>
<tr class="memitem:af16d41fad47b7c70cd619ebe506810c0" id="r_af16d41fad47b7c70cd619ebe506810c0"><td class="memTemplParams" colspan="2"><a id="af16d41fad47b7c70cd619ebe506810c0" name="af16d41fad47b7c70cd619ebe506810c0"></a>
template&lt;typename It&gt; </td></tr>
<tr class="memitem:af16d41fad47b7c70cd619ebe506810c0 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_diff_t</b> = typename <a class="el" href="structgaia_1_1core_1_1detail_1_1iterator__traits.html">detail::iterator_traits</a>&lt;It&gt;::difference_type</td></tr>
<tr class="memitem:a802d92604e7abdcdca4533fb789cfc39" id="r_a802d92604e7abdcdca4533fb789cfc39"><td class="memTemplParams" colspan="2"><a id="a802d92604e7abdcdca4533fb789cfc39" name="a802d92604e7abdcdca4533fb789cfc39"></a>
template&lt;typename... It&gt; </td></tr>
<tr class="memitem:a802d92604e7abdcdca4533fb789cfc39 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>common_diff_t</b> = std::common_type_t&lt;iterator_diff_t&lt;It&gt;...&gt;</td></tr>
<tr class="memitem:af619e1811138d117e96c2c58b079deba" id="r_af619e1811138d117e96c2c58b079deba"><td class="memTemplParams" colspan="2"><a id="af619e1811138d117e96c2c58b079deba" name="af619e1811138d117e96c2c58b079deba"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:af619e1811138d117e96c2c58b079deba template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>rem_rp_t</b> = typename <a class="el" href="structgaia_1_1core_1_1detail_1_1rem__rp.html">detail::rem_rp</a>&lt;T&gt;::type</td></tr>
<tr class="memitem:a5c0216981d43b757f2c443b710bea625" id="r_a5c0216981d43b757f2c443b710bea625"><td class="memTemplParams" colspan="2"><a id="a5c0216981d43b757f2c443b710bea625" name="a5c0216981d43b757f2c443b710bea625"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a5c0216981d43b757f2c443b710bea625 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>raw_t</b> = typename std::decay_t&lt;std::remove_pointer_t&lt;T&gt;&gt;</td></tr>
<tr class="memitem:a75dc2838ccee4d5fa5b5aa2d0c58443c" id="r_a75dc2838ccee4d5fa5b5aa2d0c58443c"><td class="memTemplParams" colspan="2"><a id="a75dc2838ccee4d5fa5b5aa2d0c58443c" name="a75dc2838ccee4d5fa5b5aa2d0c58443c"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a75dc2838ccee4d5fa5b5aa2d0c58443c template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>unique_tuple</b> = typename <a class="el" href="structgaia_1_1core_1_1unique.html">unique</a>&lt;std::tuple&lt;&gt;, Ts...&gt;::type</td></tr>
<tr class="memitem:a086ac53a0ff40f302bc9d9ff0005aefe" id="r_a086ac53a0ff40f302bc9d9ff0005aefe"><td class="memTemplParams" colspan="2"><a id="a086ac53a0ff40f302bc9d9ff0005aefe" name="a086ac53a0ff40f302bc9d9ff0005aefe"></a>
template&lt;template&lt; class... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a086ac53a0ff40f302bc9d9ff0005aefe template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>has_mfunc</b> = typename <a class="el" href="structgaia_1_1core_1_1detail_1_1member__func__checker.html">detail::member_func_checker</a>&lt;<a class="el" href="structgaia_1_1core_1_1detail_1_1member__func__none.html">detail::member_func_none</a>, void, Op, Args...&gt;::value_t</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afbc77f668e15719d31bda3ad9883f1aa" id="r_afbc77f668e15719d31bda3ad9883f1aa"><td class="memTemplParams" colspan="2"><a id="afbc77f668e15719d31bda3ad9883f1aa" name="afbc77f668e15719d31bda3ad9883f1aa"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:afbc77f668e15719d31bda3ad9883f1aa template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>swap_bits</b> (T &amp;mask, uint32_t left, uint32_t right)</td></tr>
<tr class="memitem:a5b0354fe362344e63f2a45a602590094" id="r_a5b0354fe362344e63f2a45a602590094"><td class="memTemplParams" colspan="2"><a id="a5b0354fe362344e63f2a45a602590094" name="a5b0354fe362344e63f2a45a602590094"></a>
template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a5b0354fe362344e63f2a45a602590094 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>combine_or</b> (T... t)</td></tr>
<tr class="memdesc:a5b0354fe362344e63f2a45a602590094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines values via OR. <br /></td></tr>
<tr class="memitem:aa58c4de5a1b8d97f161cd260af3f7963" id="r_aa58c4de5a1b8d97f161cd260af3f7963"><td class="memTemplParams" colspan="2"><a id="aa58c4de5a1b8d97f161cd260af3f7963" name="aa58c4de5a1b8d97f161cd260af3f7963"></a>
template&lt;typename T, typename... Rest&gt; </td></tr>
<tr class="memitem:aa58c4de5a1b8d97f161cd260af3f7963 template"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><b>hash_combine</b> (T first, T next, Rest... rest)</td></tr>
<tr class="memdesc:aa58c4de5a1b8d97f161cd260af3f7963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines hashes into another complex one. <br /></td></tr>
<tr class="memitem:a061d7a08a20597fce89b1cf95fec0ced" id="r_a061d7a08a20597fce89b1cf95fec0ced"><td class="memItemLeft" align="right" valign="top"><a id="a061d7a08a20597fce89b1cf95fec0ced" name="a061d7a08a20597fce89b1cf95fec0ced"></a>
constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_hash64</b> (const char *const str) noexcept</td></tr>
<tr class="memitem:a10a691e00dac31d29d08908df930c434" id="r_a10a691e00dac31d29d08908df930c434"><td class="memItemLeft" align="right" valign="top"><a id="a10a691e00dac31d29d08908df930c434" name="a10a691e00dac31d29d08908df930c434"></a>
constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_hash64</b> (const char *const str, const uint64_t length) noexcept</td></tr>
<tr class="memitem:a93a7e5b8168615ac4ae986c284a655de" id="r_a93a7e5b8168615ac4ae986c284a655de"><td class="memTemplParams" colspan="2"><a id="a93a7e5b8168615ac4ae986c284a655de" name="a93a7e5b8168615ac4ae986c284a655de"></a>
template&lt;typename T, size_t N&gt; </td></tr>
<tr class="memitem:a93a7e5b8168615ac4ae986c284a655de template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>span</b> (T(&amp;)[N]) -&gt; span&lt; T, N &gt;</td></tr>
<tr class="memitem:a138a3f57b6bee9da2d53095b0d7cdaaf" id="r_a138a3f57b6bee9da2d53095b0d7cdaaf"><td class="memTemplParams" colspan="2"><a id="a138a3f57b6bee9da2d53095b0d7cdaaf" name="a138a3f57b6bee9da2d53095b0d7cdaaf"></a>
template&lt;typename T, size_t N&gt; </td></tr>
<tr class="memitem:a138a3f57b6bee9da2d53095b0d7cdaaf template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>span</b> (gaia::cnt::sarray&lt; T, N &gt; &amp;) -&gt; span&lt; T, N &gt;</td></tr>
<tr class="memitem:a5e71dd4a47a39f1a2ce648c9244e244a" id="r_a5e71dd4a47a39f1a2ce648c9244e244a"><td class="memTemplParams" colspan="2"><a id="a5e71dd4a47a39f1a2ce648c9244e244a" name="a5e71dd4a47a39f1a2ce648c9244e244a"></a>
template&lt;typename T, size_t N&gt; </td></tr>
<tr class="memitem:a5e71dd4a47a39f1a2ce648c9244e244a template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>span</b> (const gaia::cnt::sarray&lt; T, N &gt; &amp;) -&gt; span&lt; const T, N &gt;</td></tr>
<tr class="memitem:a2594ab17ed98fa83ae14e86568446e41" id="r_a2594ab17ed98fa83ae14e86568446e41"><td class="memTemplParams" colspan="2"><a id="a2594ab17ed98fa83ae14e86568446e41" name="a2594ab17ed98fa83ae14e86568446e41"></a>
template&lt;typename Container&gt; </td></tr>
<tr class="memitem:a2594ab17ed98fa83ae14e86568446e41 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>span</b> (Container &amp;) -&gt; span&lt; typename std::remove_reference&lt; decltype(*detail::data(std::declval&lt; Container &amp; &gt;()))&gt;::type &gt;</td></tr>
<tr class="memitem:aa482a1c9d2a4066bcbdb39b65f032e19" id="r_aa482a1c9d2a4066bcbdb39b65f032e19"><td class="memTemplParams" colspan="2"><a id="aa482a1c9d2a4066bcbdb39b65f032e19" name="aa482a1c9d2a4066bcbdb39b65f032e19"></a>
template&lt;typename Container&gt; </td></tr>
<tr class="memitem:aa482a1c9d2a4066bcbdb39b65f032e19 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>span</b> (const Container &amp;) -&gt; span&lt; const typename Container::value_type &gt;</td></tr>
<tr class="memitem:abe52b05c0d1ad7ffdc33f6e55076e4ec" id="r_abe52b05c0d1ad7ffdc33f6e55076e4ec"><td class="memTemplParams" colspan="2"><a id="abe52b05c0d1ad7ffdc33f6e55076e4ec" name="abe52b05c0d1ad7ffdc33f6e55076e4ec"></a>
template&lt;span_size_type N, typename E, span_size_type S&gt; </td></tr>
<tr class="memitem:abe52b05c0d1ad7ffdc33f6e55076e4ec template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> (<a class="el" href="classgaia_1_1core_1_1span.html">span</a>&lt; E, S &gt; s) -&gt; decltype(s[N])</td></tr>
<tr class="memitem:ade6e5c93b71186f138d42c11c23aa28f" id="r_ade6e5c93b71186f138d42c11c23aa28f"><td class="memTemplParams" colspan="2"><a id="ade6e5c93b71186f138d42c11c23aa28f" name="ade6e5c93b71186f138d42c11c23aa28f"></a>
template&lt;typename It&gt; </td></tr>
<tr class="memitem:ade6e5c93b71186f138d42c11c23aa28f template"><td class="memItemLeft" align="right" valign="top">constexpr iterator_diff_t&lt; It &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>distance</b> (It first, It last)</td></tr>
<tr class="memitem:a7b63748bf6a2d78a81ff3260eb415cd6" id="r_a7b63748bf6a2d78a81ff3260eb415cd6"><td class="memItemLeft" align="right" valign="top"><a id="a7b63748bf6a2d78a81ff3260eb415cd6" name="a7b63748bf6a2d78a81ff3260eb415cd6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_whitespace</b> (char c)</td></tr>
<tr class="memitem:a9606caf91607b922bf0c0ca7674e2ef6" id="r_a9606caf91607b922bf0c0ca7674e2ef6"><td class="memItemLeft" align="right" valign="top"><a id="a9606caf91607b922bf0c0ca7674e2ef6" name="a9606caf91607b922bf0c0ca7674e2ef6"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>trim</b> (<a class="el" href="classstd_1_1span.html">std::span</a>&lt; const char &gt; expr)</td></tr>
<tr class="memitem:ad09aa617fbd787a173b3d4ca2f742ba6" id="r_ad09aa617fbd787a173b3d4ca2f742ba6"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ad09aa617fbd787a173b3d4ca2f742ba6 template"><td class="memItemLeft" align="right" valign="top">constexpr T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad09aa617fbd787a173b3d4ca2f742ba6">addressof</a> (T &amp;obj) noexcept</td></tr>
<tr class="memdesc:ad09aa617fbd787a173b3d4ca2f742ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the actual address of the object.  <br /></td></tr>
<tr class="memitem:a7a0f488815c35c7c9a55a81b7003c5bb" id="r_a7a0f488815c35c7c9a55a81b7003c5bb"><td class="memTemplParams" colspan="2"><a id="a7a0f488815c35c7c9a55a81b7003c5bb" name="a7a0f488815c35c7c9a55a81b7003c5bb"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a7a0f488815c35c7c9a55a81b7003c5bb template"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><b>addressof</b> (const T &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a7a0f488815c35c7c9a55a81b7003c5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rvalue overload is deleted to prevent taking the address of const rvalues. <br /></td></tr>
<tr class="memitem:a0eb672401dd59944d0eae3ddcc3703c7" id="r_a0eb672401dd59944d0eae3ddcc3703c7"><td class="memTemplParams" colspan="2"><a id="a0eb672401dd59944d0eae3ddcc3703c7" name="a0eb672401dd59944d0eae3ddcc3703c7"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a0eb672401dd59944d0eae3ddcc3703c7 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_alignment</b> (const T *ptr) noexcept</td></tr>
<tr class="memitem:ab8afa0e626084ef63f00d5eb6597fa54" id="r_ab8afa0e626084ef63f00d5eb6597fa54"><td class="memTemplParams" colspan="2"><a id="ab8afa0e626084ef63f00d5eb6597fa54" name="ab8afa0e626084ef63f00d5eb6597fa54"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ab8afa0e626084ef63f00d5eb6597fa54 template"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><b>as_bits</b> (T value)</td></tr>
<tr class="memitem:acca6ed92dade92e1a71451bdd4eb3074" id="r_acca6ed92dade92e1a71451bdd4eb3074"><td class="memTemplParams" colspan="2"><a id="acca6ed92dade92e1a71451bdd4eb3074" name="acca6ed92dade92e1a71451bdd4eb3074"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:acca6ed92dade92e1a71451bdd4eb3074 template"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><b>as_bytes</b> (T value)</td></tr>
<tr class="memitem:a361454e729e0d72f5f13109b4097ffad" id="r_a361454e729e0d72f5f13109b4097ffad"><td class="memTemplParams" colspan="2"><a id="a361454e729e0d72f5f13109b4097ffad" name="a361454e729e0d72f5f13109b4097ffad"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a361454e729e0d72f5f13109b4097ffad template"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>count_bits</b> (T number)</td></tr>
<tr class="memitem:a3056f14f7605521d16eae443392f4b78" id="r_a3056f14f7605521d16eae443392f4b78"><td class="memTemplParams" colspan="2"><a id="a3056f14f7605521d16eae443392f4b78" name="a3056f14f7605521d16eae443392f4b78"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a3056f14f7605521d16eae443392f4b78 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_pow2</b> (T number)</td></tr>
<tr class="memitem:ac293b1948a43c667adc5e8578f04e159" id="r_ac293b1948a43c667adc5e8578f04e159"><td class="memTemplParams" colspan="2"><a id="ac293b1948a43c667adc5e8578f04e159" name="ac293b1948a43c667adc5e8578f04e159"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ac293b1948a43c667adc5e8578f04e159 template"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><b>closest_pow2</b> (T number)</td></tr>
<tr class="memitem:aac63132486ad640dc568185efb6f86bf" id="r_aac63132486ad640dc568185efb6f86bf"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aac63132486ad640dc568185efb6f86bf template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac63132486ad640dc568185efb6f86bf">call_ctor_raw</a> (T *pData)</td></tr>
<tr class="memdesc:aac63132486ad640dc568185efb6f86bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type <em class="arg">T</em> in the uninitialized storage at the memory address <em class="arg">pData</em>.  <br /></td></tr>
<tr class="memitem:afa62b150418f1c4b5a39fb0f3ca0caad" id="r_afa62b150418f1c4b5a39fb0f3ca0caad"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:afa62b150418f1c4b5a39fb0f3ca0caad template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa62b150418f1c4b5a39fb0f3ca0caad">call_ctor_raw_n</a> (T *pData, size_t <a class="el" href="namespacegaia_1_1cnt.html">cnt</a>)</td></tr>
<tr class="memdesc:afa62b150418f1c4b5a39fb0f3ca0caad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <em class="arg">cnt</em> objects of type <em class="arg">T</em> in the uninitialized storage at the memory address <em class="arg">pData</em>.  <br /></td></tr>
<tr class="memitem:a295df67d6d1d214c7f1ba4811653908f" id="r_a295df67d6d1d214c7f1ba4811653908f"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a295df67d6d1d214c7f1ba4811653908f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a295df67d6d1d214c7f1ba4811653908f">call_ctor_val</a> (T *pData)</td></tr>
<tr class="memdesc:a295df67d6d1d214c7f1ba4811653908f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value-constructs an object of type <em class="arg">T</em> in the uninitialized storage at the memory address <em class="arg">pData</em>.  <br /></td></tr>
<tr class="memitem:a3ac59173e286302735c343d2203f72bc" id="r_a3ac59173e286302735c343d2203f72bc"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a3ac59173e286302735c343d2203f72bc template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ac59173e286302735c343d2203f72bc">call_ctor_val_n</a> (T *pData, size_t <a class="el" href="namespacegaia_1_1cnt.html">cnt</a>)</td></tr>
<tr class="memdesc:a3ac59173e286302735c343d2203f72bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value-constructs <em class="arg">cnt</em> objects of type <em class="arg">T</em> in the uninitialized storage at the memory address <em class="arg">pData</em>.  <br /></td></tr>
<tr class="memitem:a0addcb0ec5043a16a9cfbf3349f7d8f6" id="r_a0addcb0ec5043a16a9cfbf3349f7d8f6"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a0addcb0ec5043a16a9cfbf3349f7d8f6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0addcb0ec5043a16a9cfbf3349f7d8f6">call_ctor</a> (T *pData)</td></tr>
<tr class="memdesc:a0addcb0ec5043a16a9cfbf3349f7d8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type <em class="arg">T</em> at the given memory address.  <br /></td></tr>
<tr class="memitem:a34727fe8a5b09c2c8bf5bfc65e890f22" id="r_a34727fe8a5b09c2c8bf5bfc65e890f22"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a34727fe8a5b09c2c8bf5bfc65e890f22 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34727fe8a5b09c2c8bf5bfc65e890f22">call_ctor_n</a> (T *pData, size_t <a class="el" href="namespacegaia_1_1cnt.html">cnt</a>)</td></tr>
<tr class="memdesc:a34727fe8a5b09c2c8bf5bfc65e890f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <em class="arg">cnt</em> objects of type <em class="arg">T</em> at the memory address <em class="arg">pData</em>.  <br /></td></tr>
<tr class="memitem:a17ae142d4654db429601b83f56a39e5e" id="r_a17ae142d4654db429601b83f56a39e5e"><td class="memTemplParams" colspan="2"><a id="a17ae142d4654db429601b83f56a39e5e" name="a17ae142d4654db429601b83f56a39e5e"></a>
template&lt;typename T, typename... Args&gt; </td></tr>
<tr class="memitem:a17ae142d4654db429601b83f56a39e5e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>call_ctor</b> (T *pData, Args &amp;&amp;... args)</td></tr>
<tr class="memitem:a35ed5fc7e07b3d4ba9fa198d71762440" id="r_a35ed5fc7e07b3d4ba9fa198d71762440"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a35ed5fc7e07b3d4ba9fa198d71762440 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35ed5fc7e07b3d4ba9fa198d71762440">call_dtor</a> (T *pData)</td></tr>
<tr class="memdesc:a35ed5fc7e07b3d4ba9fa198d71762440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs an object of type <em class="arg">T</em> at the given memory address.  <br /></td></tr>
<tr class="memitem:ad9c74703bee60369368d3132e617280c" id="r_ad9c74703bee60369368d3132e617280c"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ad9c74703bee60369368d3132e617280c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9c74703bee60369368d3132e617280c">call_dtor_n</a> (T *pData, size_t <a class="el" href="namespacegaia_1_1cnt.html">cnt</a>)</td></tr>
<tr class="memdesc:ad9c74703bee60369368d3132e617280c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs <em class="arg">cnt</em> objects of type <em class="arg">T</em> at the memory address <em class="arg">pData</em>.  <br /></td></tr>
<tr class="memitem:ac2e653f1bf52609dac5bb186e86e9ce7" id="r_ac2e653f1bf52609dac5bb186e86e9ce7"><td class="memTemplParams" colspan="2"><a id="ac2e653f1bf52609dac5bb186e86e9ce7" name="ac2e653f1bf52609dac5bb186e86e9ce7"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ac2e653f1bf52609dac5bb186e86e9ce7 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (T &amp;left, T &amp;right)</td></tr>
<tr class="memitem:a99b20174e5cf1843675d383ccdb70cb5" id="r_a99b20174e5cf1843675d383ccdb70cb5"><td class="memTemplParams" colspan="2"><a id="a99b20174e5cf1843675d383ccdb70cb5" name="a99b20174e5cf1843675d383ccdb70cb5"></a>
template&lt;typename T, typename TCmpFunc&gt; </td></tr>
<tr class="memitem:a99b20174e5cf1843675d383ccdb70cb5 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>swap_if</b> (T *c, size_t lhs, size_t rhs, TCmpFunc cmpFunc) noexcept</td></tr>
<tr class="memitem:a3b4cff1c1f03c7de21faed1fcec5a42d" id="r_a3b4cff1c1f03c7de21faed1fcec5a42d"><td class="memTemplParams" colspan="2"><a id="a3b4cff1c1f03c7de21faed1fcec5a42d" name="a3b4cff1c1f03c7de21faed1fcec5a42d"></a>
template&lt;typename T, typename TCmpFunc&gt; </td></tr>
<tr class="memitem:a3b4cff1c1f03c7de21faed1fcec5a42d template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>swap_if</b> (T &amp;lhs, T &amp;rhs, TCmpFunc cmpFunc) noexcept</td></tr>
<tr class="memitem:af6fb5f20c540960c26b85229bd40f32c" id="r_af6fb5f20c540960c26b85229bd40f32c"><td class="memTemplParams" colspan="2"><a id="af6fb5f20c540960c26b85229bd40f32c" name="af6fb5f20c540960c26b85229bd40f32c"></a>
template&lt;typename T, typename TCmpFunc&gt; </td></tr>
<tr class="memitem:af6fb5f20c540960c26b85229bd40f32c template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>swap_if_not</b> (T &amp;lhs, T &amp;rhs, TCmpFunc cmpFunc) noexcept</td></tr>
<tr class="memitem:af52d421eea3de1e9557cce9c5c62c8fd" id="r_af52d421eea3de1e9557cce9c5c62c8fd"><td class="memTemplParams" colspan="2"><a id="af52d421eea3de1e9557cce9c5c62c8fd" name="af52d421eea3de1e9557cce9c5c62c8fd"></a>
template&lt;typename T, typename TCmpFunc, typename TSwapFunc&gt; </td></tr>
<tr class="memitem:af52d421eea3de1e9557cce9c5c62c8fd template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>try_swap_if</b> (T *c, uint32_t lhs, uint32_t rhs, TCmpFunc cmpFunc, TSwapFunc swapFunc) noexcept</td></tr>
<tr class="memitem:a20d0add30f406d7a8231b3434935cbd3" id="r_a20d0add30f406d7a8231b3434935cbd3"><td class="memTemplParams" colspan="2"><a id="a20d0add30f406d7a8231b3434935cbd3" name="a20d0add30f406d7a8231b3434935cbd3"></a>
template&lt;typename C, typename TCmpFunc, typename TSwapFunc&gt; </td></tr>
<tr class="memitem:a20d0add30f406d7a8231b3434935cbd3 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>try_swap_if</b> (C &amp;c, typename C::size_type lhs, typename C::size_type rhs, TCmpFunc cmpFunc, TSwapFunc swapFunc) noexcept</td></tr>
<tr class="memitem:a3b584abc758ebcd13f9e5551faa78447" id="r_a3b584abc758ebcd13f9e5551faa78447"><td class="memTemplParams" colspan="2"><a id="a3b584abc758ebcd13f9e5551faa78447" name="a3b584abc758ebcd13f9e5551faa78447"></a>
template&lt;typename C, typename TCmpFunc, typename TSwapFunc&gt; </td></tr>
<tr class="memitem:a3b584abc758ebcd13f9e5551faa78447 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>try_swap_if_not</b> (C &amp;c, typename C::size_type lhs, typename C::size_type rhs, TCmpFunc cmpFunc, TSwapFunc swapFunc) noexcept</td></tr>
<tr class="memitem:ac40bf7887246dcdb2a293272e1711f68" id="r_ac40bf7887246dcdb2a293272e1711f68"><td class="memTemplParams" colspan="2"><a id="ac40bf7887246dcdb2a293272e1711f68" name="ac40bf7887246dcdb2a293272e1711f68"></a>
template&lt;class ForwardIt, class T&gt; </td></tr>
<tr class="memitem:ac40bf7887246dcdb2a293272e1711f68 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>fill</b> (ForwardIt first, ForwardIt last, const T &amp;value)</td></tr>
<tr class="memitem:a95bac028f20eea2bbd8822ee19a7ff30" id="r_a95bac028f20eea2bbd8822ee19a7ff30"><td class="memTemplParams" colspan="2"><a id="a95bac028f20eea2bbd8822ee19a7ff30" name="a95bac028f20eea2bbd8822ee19a7ff30"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a95bac028f20eea2bbd8822ee19a7ff30 template"><td class="memItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_min</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memitem:a4b28928f710351bb7ea3a68fe497b748" id="r_a4b28928f710351bb7ea3a68fe497b748"><td class="memTemplParams" colspan="2"><a id="a4b28928f710351bb7ea3a68fe497b748" name="a4b28928f710351bb7ea3a68fe497b748"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a4b28928f710351bb7ea3a68fe497b748 template"><td class="memItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_max</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memitem:abbf6b9be62ba93c3253e33a51dd630c0" id="r_abbf6b9be62ba93c3253e33a51dd630c0"><td class="memTemplParams" colspan="2"><a id="abbf6b9be62ba93c3253e33a51dd630c0" name="abbf6b9be62ba93c3253e33a51dd630c0"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abbf6b9be62ba93c3253e33a51dd630c0 template"><td class="memItemLeft" align="right" valign="top">constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>get_args_size</b> (std::tuple&lt; Args... &gt; const &amp;)</td></tr>
<tr class="memitem:ae724d7250d549f5a5fb3acb4380895d7" id="r_ae724d7250d549f5a5fb3acb4380895d7"><td class="memTemplParams" colspan="2"><a id="ae724d7250d549f5a5fb3acb4380895d7" name="ae724d7250d549f5a5fb3acb4380895d7"></a>
template&lt;typename Class, typename Ret, typename... Args&gt; </td></tr>
<tr class="memitem:ae724d7250d549f5a5fb3acb4380895d7 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgaia_1_1core_1_1func__type__list.html">func_type_list</a>&lt; Args... &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>func_args</b> (Ret(Class::*)(Args...) const)</td></tr>
<tr class="memitem:a1daae4ea6135943e91a4e80772e4d2d2" id="r_a1daae4ea6135943e91a4e80772e4d2d2"><td class="memItemLeft" align="right" valign="top"><a id="a1daae4ea6135943e91a4e80772e4d2d2" name="a1daae4ea6135943e91a4e80772e4d2d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GAIA_DEFINE_HAS_MEMBER_FUNC</b> (find)</td></tr>
<tr class="memitem:a52a26c5250e8663ae2f83b33abf496cc" id="r_a52a26c5250e8663ae2f83b33abf496cc"><td class="memItemLeft" align="right" valign="top"><a id="a52a26c5250e8663ae2f83b33abf496cc" name="a52a26c5250e8663ae2f83b33abf496cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GAIA_DEFINE_HAS_MEMBER_FUNC</b> (find_if)</td></tr>
<tr class="memitem:a448c8ce8bf95d24ca0072a75d740d879" id="r_a448c8ce8bf95d24ca0072a75d740d879"><td class="memItemLeft" align="right" valign="top"><a id="a448c8ce8bf95d24ca0072a75d740d879" name="a448c8ce8bf95d24ca0072a75d740d879"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GAIA_DEFINE_HAS_MEMBER_FUNC</b> (find_if_not)</td></tr>
<tr class="memitem:a00878ab0e950060e7b2a404ce4346e05" id="r_a00878ab0e950060e7b2a404ce4346e05"><td class="memTemplParams" colspan="2">template&lt;auto Iters, typename Func&gt; </td></tr>
<tr class="memitem:a00878ab0e950060e7b2a404ce4346e05 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00878ab0e950060e7b2a404ce4346e05">each</a> (Func func)</td></tr>
<tr class="memdesc:a00878ab0e950060e7b2a404ce4346e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time for loop. Performs.  <br /></td></tr>
<tr class="memitem:a4acb645e18169c91361106ea0c3eca54" id="r_a4acb645e18169c91361106ea0c3eca54"><td class="memTemplParams" colspan="2">template&lt;auto FirstIdx, auto LastIdx, typename Func&gt; </td></tr>
<tr class="memitem:a4acb645e18169c91361106ea0c3eca54 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4acb645e18169c91361106ea0c3eca54">each_ext</a> (Func func)</td></tr>
<tr class="memdesc:a4acb645e18169c91361106ea0c3eca54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time for loop with adjustable range. Iteration starts at.  <br /></td></tr>
<tr class="memitem:a4bd577776f837fefab5ab7acf8dc0dab" id="r_a4bd577776f837fefab5ab7acf8dc0dab"><td class="memTemplParams" colspan="2">template&lt;auto FirstIdx, auto LastIdx, auto Inc, typename Func&gt; </td></tr>
<tr class="memitem:a4bd577776f837fefab5ab7acf8dc0dab template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bd577776f837fefab5ab7acf8dc0dab">each_ext</a> (Func func)</td></tr>
<tr class="memdesc:a4bd577776f837fefab5ab7acf8dc0dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time for loop with adjustable range and iteration size. Iteration starts at.  <br /></td></tr>
<tr class="memitem:a5a9456f790d80f3e355e86280a1c0018" id="r_a5a9456f790d80f3e355e86280a1c0018"><td class="memTemplParams" colspan="2">template&lt;typename Func, typename... Args&gt; </td></tr>
<tr class="memitem:a5a9456f790d80f3e355e86280a1c0018 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a9456f790d80f3e355e86280a1c0018">each_pack</a> (Func func, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5a9456f790d80f3e355e86280a1c0018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time for loop over parameter packs.  <br /></td></tr>
<tr class="memitem:a14f553e6938d7cebcdaaf2539dae439a" id="r_a14f553e6938d7cebcdaaf2539dae439a"><td class="memTemplParams" colspan="2">template&lt;typename Tuple, typename Func&gt; </td></tr>
<tr class="memitem:a14f553e6938d7cebcdaaf2539dae439a template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14f553e6938d7cebcdaaf2539dae439a">each_tuple</a> (Tuple &amp;&amp;tuple, Func func)</td></tr>
<tr class="memdesc:a14f553e6938d7cebcdaaf2539dae439a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time for loop over tuples and other objects implementing tuple_size (sarray, std::pair etc).  <br /></td></tr>
<tr class="memitem:ad4cb6904c9e9ec556c0e1a2f2248e5c7" id="r_ad4cb6904c9e9ec556c0e1a2f2248e5c7"><td class="memTemplParams" colspan="2">template&lt;typename Tuple, typename Func&gt; </td></tr>
<tr class="memitem:ad4cb6904c9e9ec556c0e1a2f2248e5c7 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4cb6904c9e9ec556c0e1a2f2248e5c7">each_tuple</a> (Func func)</td></tr>
<tr class="memdesc:ad4cb6904c9e9ec556c0e1a2f2248e5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time for loop over tuples and other objects implementing tuple_size (sarray, std::pair etc).  <br /></td></tr>
<tr class="memitem:ac417c3dccaae72ead9a3448a584fd63b" id="r_ac417c3dccaae72ead9a3448a584fd63b"><td class="memTemplParams" colspan="2">template&lt;auto FirstIdx, auto LastIdx, typename Tuple, typename Func&gt; </td></tr>
<tr class="memitem:ac417c3dccaae72ead9a3448a584fd63b template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac417c3dccaae72ead9a3448a584fd63b">each_tuple_ext</a> (Tuple &amp;&amp;tuple, Func func)</td></tr>
<tr class="memdesc:ac417c3dccaae72ead9a3448a584fd63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time for loop over tuples and other objects implementing tuple_size (sarray, std::pair etc). Iteration starts at.  <br /></td></tr>
<tr class="memitem:ad49ddfc3b59c778b9982d66adfe13a1e" id="r_ad49ddfc3b59c778b9982d66adfe13a1e"><td class="memTemplParams" colspan="2">template&lt;auto FirstIdx, auto LastIdx, typename Tuple, typename Func&gt; </td></tr>
<tr class="memitem:ad49ddfc3b59c778b9982d66adfe13a1e template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad49ddfc3b59c778b9982d66adfe13a1e">each_tuple_ext</a> (Func func)</td></tr>
<tr class="memdesc:ad49ddfc3b59c778b9982d66adfe13a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time for loop over tuples and other objects implementing tuple_size (sarray, std::pair etc). Iteration starts at.  <br /></td></tr>
<tr class="memitem:a3e3b0c75799f3708220deb129ef4eb1a" id="r_a3e3b0c75799f3708220deb129ef4eb1a"><td class="memTemplParams" colspan="2"><a id="a3e3b0c75799f3708220deb129ef4eb1a" name="a3e3b0c75799f3708220deb129ef4eb1a"></a>
template&lt;typename InputIt, typename Func&gt; </td></tr>
<tr class="memitem:a3e3b0c75799f3708220deb129ef4eb1a template"><td class="memItemLeft" align="right" valign="top">constexpr Func&#160;</td><td class="memItemRight" valign="bottom"><b>each</b> (InputIt first, InputIt last, Func func)</td></tr>
<tr class="memitem:a3600d7cae96510725e61eb11efbc07a9" id="r_a3600d7cae96510725e61eb11efbc07a9"><td class="memTemplParams" colspan="2"><a id="a3600d7cae96510725e61eb11efbc07a9" name="a3600d7cae96510725e61eb11efbc07a9"></a>
template&lt;typename C, typename Func&gt; </td></tr>
<tr class="memitem:a3600d7cae96510725e61eb11efbc07a9 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>each</b> (const C &amp;arr, Func func)</td></tr>
<tr class="memitem:af85bacf2f8e915bca084baf1dd2407d1" id="r_af85bacf2f8e915bca084baf1dd2407d1"><td class="memTemplParams" colspan="2"><a id="af85bacf2f8e915bca084baf1dd2407d1" name="af85bacf2f8e915bca084baf1dd2407d1"></a>
template&lt;typename InputIt, typename T&gt; </td></tr>
<tr class="memitem:af85bacf2f8e915bca084baf1dd2407d1 template"><td class="memItemLeft" align="right" valign="top">constexpr InputIt&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (InputIt first, InputIt last, const T &amp;value)</td></tr>
<tr class="memitem:a0383190f027331a76a60f1ee75642fbd" id="r_a0383190f027331a76a60f1ee75642fbd"><td class="memTemplParams" colspan="2"><a id="a0383190f027331a76a60f1ee75642fbd" name="a0383190f027331a76a60f1ee75642fbd"></a>
template&lt;typename C, typename V&gt; </td></tr>
<tr class="memitem:a0383190f027331a76a60f1ee75642fbd template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (const C &amp;arr, const V &amp;item)</td></tr>
<tr class="memitem:ae4af5b83fe9c91570f9131eb25bf12fd" id="r_ae4af5b83fe9c91570f9131eb25bf12fd"><td class="memTemplParams" colspan="2"><a id="ae4af5b83fe9c91570f9131eb25bf12fd" name="ae4af5b83fe9c91570f9131eb25bf12fd"></a>
template&lt;typename InputIt, typename Func&gt; </td></tr>
<tr class="memitem:ae4af5b83fe9c91570f9131eb25bf12fd template"><td class="memItemLeft" align="right" valign="top">constexpr InputIt&#160;</td><td class="memItemRight" valign="bottom"><b>find_if</b> (InputIt first, InputIt last, Func func)</td></tr>
<tr class="memitem:a4a446de036180b9d670f07636469a4bd" id="r_a4a446de036180b9d670f07636469a4bd"><td class="memTemplParams" colspan="2"><a id="a4a446de036180b9d670f07636469a4bd" name="a4a446de036180b9d670f07636469a4bd"></a>
template&lt;typename UnaryPredicate, typename C&gt; </td></tr>
<tr class="memitem:a4a446de036180b9d670f07636469a4bd template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>find_if</b> (const C &amp;arr, UnaryPredicate predicate)</td></tr>
<tr class="memitem:ae181052048eb5cc7db17c1671153e609" id="r_ae181052048eb5cc7db17c1671153e609"><td class="memTemplParams" colspan="2"><a id="ae181052048eb5cc7db17c1671153e609" name="ae181052048eb5cc7db17c1671153e609"></a>
template&lt;typename InputIt, typename Func&gt; </td></tr>
<tr class="memitem:ae181052048eb5cc7db17c1671153e609 template"><td class="memItemLeft" align="right" valign="top">constexpr InputIt&#160;</td><td class="memItemRight" valign="bottom"><b>find_if_not</b> (InputIt first, InputIt last, Func func)</td></tr>
<tr class="memitem:a58d3db7db1ba09bdad0f7827cc69a5ae" id="r_a58d3db7db1ba09bdad0f7827cc69a5ae"><td class="memTemplParams" colspan="2"><a id="a58d3db7db1ba09bdad0f7827cc69a5ae" name="a58d3db7db1ba09bdad0f7827cc69a5ae"></a>
template&lt;typename UnaryPredicate, typename C&gt; </td></tr>
<tr class="memitem:a58d3db7db1ba09bdad0f7827cc69a5ae template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>find_if_not</b> (const C &amp;arr, UnaryPredicate predicate)</td></tr>
<tr class="memitem:a82a75a63bca87daf46be5cadebee37e7" id="r_a82a75a63bca87daf46be5cadebee37e7"><td class="memTemplParams" colspan="2"><a id="a82a75a63bca87daf46be5cadebee37e7" name="a82a75a63bca87daf46be5cadebee37e7"></a>
template&lt;typename C, typename V&gt; </td></tr>
<tr class="memitem:a82a75a63bca87daf46be5cadebee37e7 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>has</b> (const C &amp;arr, const V &amp;item)</td></tr>
<tr class="memitem:a859da78194b0f838542f059a96f2e1bd" id="r_a859da78194b0f838542f059a96f2e1bd"><td class="memTemplParams" colspan="2"><a id="a859da78194b0f838542f059a96f2e1bd" name="a859da78194b0f838542f059a96f2e1bd"></a>
template&lt;typename UnaryPredicate, typename C&gt; </td></tr>
<tr class="memitem:a859da78194b0f838542f059a96f2e1bd template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_if</b> (const C &amp;arr, UnaryPredicate predicate)</td></tr>
<tr class="memitem:a66fde302673973c0d12853c8df480b14" id="r_a66fde302673973c0d12853c8df480b14"><td class="memTemplParams" colspan="2"><a id="a66fde302673973c0d12853c8df480b14" name="a66fde302673973c0d12853c8df480b14"></a>
template&lt;typename C&gt; </td></tr>
<tr class="memitem:a66fde302673973c0d12853c8df480b14 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>get_index</b> (const C &amp;arr, typename C::const_reference item)</td></tr>
<tr class="memitem:a9766e480be935164bc3c9b87e0e6aae6" id="r_a9766e480be935164bc3c9b87e0e6aae6"><td class="memTemplParams" colspan="2"><a id="a9766e480be935164bc3c9b87e0e6aae6" name="a9766e480be935164bc3c9b87e0e6aae6"></a>
template&lt;typename C&gt; </td></tr>
<tr class="memitem:a9766e480be935164bc3c9b87e0e6aae6 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_unsafe</b> (const C &amp;arr, typename C::const_reference item)</td></tr>
<tr class="memitem:a6545d07df0b89cc59fb1bd227caa48a4" id="r_a6545d07df0b89cc59fb1bd227caa48a4"><td class="memTemplParams" colspan="2"><a id="a6545d07df0b89cc59fb1bd227caa48a4" name="a6545d07df0b89cc59fb1bd227caa48a4"></a>
template&lt;typename UnaryPredicate, typename C&gt; </td></tr>
<tr class="memitem:a6545d07df0b89cc59fb1bd227caa48a4 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_if</b> (const C &amp;arr, UnaryPredicate predicate)</td></tr>
<tr class="memitem:a4aae150a67e813d50f57ae79fa64f5a0" id="r_a4aae150a67e813d50f57ae79fa64f5a0"><td class="memTemplParams" colspan="2"><a id="a4aae150a67e813d50f57ae79fa64f5a0" name="a4aae150a67e813d50f57ae79fa64f5a0"></a>
template&lt;typename UnaryPredicate, typename C&gt; </td></tr>
<tr class="memitem:a4aae150a67e813d50f57ae79fa64f5a0 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_if_unsafe</b> (const C &amp;arr, UnaryPredicate predicate)</td></tr>
<tr class="memitem:a5cca46165fa888f2b19201daff21fd10" id="r_a5cca46165fa888f2b19201daff21fd10"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:a5cca46165fa888f2b19201daff21fd10 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cca46165fa888f2b19201daff21fd10">swap_erase_unsafe</a> (C &amp;arr, typename C::size_type idx)</td></tr>
<tr class="memdesc:a5cca46165fa888f2b19201daff21fd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the item at <em class="arg">idx</em> in the array <em class="arg">arr</em> with the last item of the array if possible and removes its last item. Use when shifting of the entire array is not wanted.  <br /></td></tr>
<tr class="memitem:a4243d49bb085eeae237b6330b9e76bd1" id="r_a4243d49bb085eeae237b6330b9e76bd1"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:a4243d49bb085eeae237b6330b9e76bd1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4243d49bb085eeae237b6330b9e76bd1">swap_erase</a> (C &amp;arr, typename C::size_type idx)</td></tr>
<tr class="memdesc:a4243d49bb085eeae237b6330b9e76bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the item at <em class="arg">idx</em> in the array <em class="arg">arr</em> with the last item of the array if possible and removes its last item. Use when shifting of the entire array is not wanted.  <br /></td></tr>
<tr class="memitem:a33f45fa68687ed956606ef9b2b471e65" id="r_a33f45fa68687ed956606ef9b2b471e65"><td class="memTemplParams" colspan="2"><a id="a33f45fa68687ed956606ef9b2b471e65" name="a33f45fa68687ed956606ef9b2b471e65"></a>
template&lt;typename Container, typename TCmpFunc&gt; </td></tr>
<tr class="memitem:a33f45fa68687ed956606ef9b2b471e65 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>quick_sort</b> (Container &amp;arr, int low, int high, TCmpFunc cmpFunc)</td></tr>
<tr class="memitem:a4706bcd3b02f00a6e236102da0f24782" id="r_a4706bcd3b02f00a6e236102da0f24782"><td class="memTemplParams" colspan="2"><a id="a4706bcd3b02f00a6e236102da0f24782" name="a4706bcd3b02f00a6e236102da0f24782"></a>
template&lt;typename Container, typename TCmpFunc, typename TSwapFunc&gt; </td></tr>
<tr class="memitem:a4706bcd3b02f00a6e236102da0f24782 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>quick_sort</b> (Container &amp;arr, int low, int high, TCmpFunc cmpFunc, TSwapFunc swapFunc)</td></tr>
<tr class="memitem:a6b8e474fbd36fcc7f89a908107e9fbc1" id="r_a6b8e474fbd36fcc7f89a908107e9fbc1"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename TCmpFunc, typename TSwapFunc&gt; </td></tr>
<tr class="memitem:a6b8e474fbd36fcc7f89a908107e9fbc1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b8e474fbd36fcc7f89a908107e9fbc1">quick_sort_stack</a> (Container &amp;arr, int low, int high, TCmpFunc cmpFunc, TSwapFunc swapFunc, uint32_t maxStackSize)</td></tr>
<tr class="memdesc:a6b8e474fbd36fcc7f89a908107e9fbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special version of the quick sort algorithm. Instead of relying on recursion it allocates an acceleration structure on the stack.  <br /></td></tr>
<tr class="memitem:a4d9686a728c1ca30ff83a8f5808af340" id="r_a4d9686a728c1ca30ff83a8f5808af340"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename TCmpFunc&gt; </td></tr>
<tr class="memitem:a4d9686a728c1ca30ff83a8f5808af340 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d9686a728c1ca30ff83a8f5808af340">quick_sort_stack</a> (Container &amp;arr, int low, int high, TCmpFunc cmpFunc, uint32_t maxStackSize)</td></tr>
<tr class="memdesc:a4d9686a728c1ca30ff83a8f5808af340"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special version of the quick sort algorithm. Instead of relying on recursion it allocates an acceleration structure on the stack.  <br /></td></tr>
<tr class="memitem:a750a65f7b8957f39c44de8126afc9a86" id="r_a750a65f7b8957f39c44de8126afc9a86"><td class="memTemplParams" colspan="2">template&lt;typename T, typename TCmpFunc&gt; </td></tr>
<tr class="memitem:a750a65f7b8957f39c44de8126afc9a86 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a750a65f7b8957f39c44de8126afc9a86">sort</a> (T *beg, T *end, TCmpFunc cmpFunc)</td></tr>
<tr class="memdesc:a750a65f7b8957f39c44de8126afc9a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a range of elements. Sorting network is used up to 8 elements. Bubble-sort is used up to 32 elements. For anything else, quicksort is used. Use when it is necessary to sort multiple arrays at once.  <br /></td></tr>
<tr class="memitem:aa146359517df42c358a42c7f32b90bb1" id="r_aa146359517df42c358a42c7f32b90bb1"><td class="memTemplParams" colspan="2"><a id="aa146359517df42c358a42c7f32b90bb1" name="aa146359517df42c358a42c7f32b90bb1"></a>
template&lt;typename C, typename TCmpFunc&gt; </td></tr>
<tr class="memitem:aa146359517df42c358a42c7f32b90bb1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>sort</b> (C &amp;c, TCmpFunc cmpFunc)</td></tr>
<tr class="memitem:acb0855ba2c1593cdd5657d226b8af722" id="r_acb0855ba2c1593cdd5657d226b8af722"><td class="memTemplParams" colspan="2">template&lt;typename T, typename TCmpFunc, typename TSwapFunc&gt; </td></tr>
<tr class="memitem:acb0855ba2c1593cdd5657d226b8af722 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb0855ba2c1593cdd5657d226b8af722">sort</a> (T *beg, T *end, TCmpFunc cmpFunc, TSwapFunc swapFunc)</td></tr>
<tr class="memdesc:acb0855ba2c1593cdd5657d226b8af722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a range of elements given a comparison function <em class="arg">cmpFunc</em>. If <em class="arg">cmpFunc</em> returns true it performs <em class="arg">swapFunc</em> which can perform the sorting. Sorting network is used up to 8 elements. Bubble-sort is used up to 32 elements. For anything else, quicksort is used. Use when it is necessary to sort multiple arrays at once.  <br /></td></tr>
<tr class="memitem:a6b62bf25f4f2f296e24010948a07e988" id="r_a6b62bf25f4f2f296e24010948a07e988"><td class="memTemplParams" colspan="2"><a id="a6b62bf25f4f2f296e24010948a07e988" name="a6b62bf25f4f2f296e24010948a07e988"></a>
template&lt;typename C, typename TCmpFunc, typename TSwapFunc&gt; </td></tr>
<tr class="memitem:a6b62bf25f4f2f296e24010948a07e988 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>sort</b> (C &amp;c, TCmpFunc cmpFunc, TSwapFunc swapFunc)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac6287e1787c188ea0c8cd0fcf4267b71" id="r_ac6287e1787c188ea0c8cd0fcf4267b71"><td class="memTemplParams" colspan="2"><a id="ac6287e1787c188ea0c8cd0fcf4267b71" name="ac6287e1787c188ea0c8cd0fcf4267b71"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ac6287e1787c188ea0c8cd0fcf4267b71 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_direct_hash_key_v</b> = <a class="el" href="structgaia_1_1core_1_1detail_1_1is__direct__hash__key.html">detail::is_direct_hash_key</a>&lt;T&gt;::value</td></tr>
<tr class="memitem:a1f6981b00ef408ae7603b481b313c092" id="r_a1f6981b00ef408ae7603b481b313c092"><td class="memItemLeft" align="right" valign="top"><a id="a1f6981b00ef408ae7603b481b313c092" name="a1f6981b00ef408ae7603b481b313c092"></a>
constexpr span_size_type&#160;</td><td class="memItemRight" valign="bottom"><b>DynamicSpanExtent</b> = (span_size_type)-1</td></tr>
<tr class="memitem:ac850f7853a1d78421f44c48395776a7e" id="r_ac850f7853a1d78421f44c48395776a7e"><td class="memTemplParams" colspan="2"><a id="ac850f7853a1d78421f44c48395776a7e" name="ac850f7853a1d78421f44c48395776a7e"></a>
template&lt;typename T, typename = void&gt; </td></tr>
<tr class="memitem:ac850f7853a1d78421f44c48395776a7e template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_iterator_v</b> = false</td></tr>
<tr class="memitem:a1a54b0c358258aee8d9527332dfa9390" id="r_a1a54b0c358258aee8d9527332dfa9390"><td class="memTemplParams" colspan="2"><a id="a1a54b0c358258aee8d9527332dfa9390" name="a1a54b0c358258aee8d9527332dfa9390"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a1a54b0c358258aee8d9527332dfa9390 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_iterator_v&lt; T, std::void_t&lt; detail::iterator_cat_t&lt; T &gt; &gt; &gt;</b> = true</td></tr>
<tr class="memitem:a386b8abad014ad2733222e8f31b2339f" id="r_a386b8abad014ad2733222e8f31b2339f"><td class="memTemplParams" colspan="2">template&lt;typename It&gt; </td></tr>
<tr class="memitem:a386b8abad014ad2733222e8f31b2339f template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a386b8abad014ad2733222e8f31b2339f">is_input_iter_v</a></td></tr>
<tr class="memitem:a13a0e5893d2992e75035ea1b0eec9248" id="r_a13a0e5893d2992e75035ea1b0eec9248"><td class="memTemplParams" colspan="2">template&lt;typename It&gt; </td></tr>
<tr class="memitem:a13a0e5893d2992e75035ea1b0eec9248 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13a0e5893d2992e75035ea1b0eec9248">is_fwd_iter_v</a></td></tr>
<tr class="memitem:a282cfebb703ebbe76d8d8c1e740906b4" id="r_a282cfebb703ebbe76d8d8c1e740906b4"><td class="memTemplParams" colspan="2">template&lt;typename It&gt; </td></tr>
<tr class="memitem:a282cfebb703ebbe76d8d8c1e740906b4 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a282cfebb703ebbe76d8d8c1e740906b4">is_rev_iter_v</a></td></tr>
<tr class="memitem:a858d3a926731f0fae03f91a8fc9d3722" id="r_a858d3a926731f0fae03f91a8fc9d3722"><td class="memTemplParams" colspan="2">template&lt;typename It&gt; </td></tr>
<tr class="memitem:a858d3a926731f0fae03f91a8fc9d3722 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a858d3a926731f0fae03f91a8fc9d3722">is_bidi_iter_v</a></td></tr>
<tr class="memitem:a91cf58b531e633cd06585bc2ff77ad73" id="r_a91cf58b531e633cd06585bc2ff77ad73"><td class="memTemplParams" colspan="2">template&lt;typename It&gt; </td></tr>
<tr class="memitem:a91cf58b531e633cd06585bc2ff77ad73 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91cf58b531e633cd06585bc2ff77ad73">is_random_iter_v</a></td></tr>
<tr class="memitem:a95f5986c986a5b64f692b320bb2dd268" id="r_a95f5986c986a5b64f692b320bb2dd268"><td class="memItemLeft" align="right" valign="top"><a id="a95f5986c986a5b64f692b320bb2dd268" name="a95f5986c986a5b64f692b320bb2dd268"></a>
constexpr <a class="el" href="structgaia_1_1core_1_1zero__t.html">zero_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>zero</b> {}</td></tr>
<tr class="memitem:aaf8c218d42e3946e3aa8b2f60511809f" id="r_aaf8c218d42e3946e3aa8b2f60511809f"><td class="memTemplParams" colspan="2"><a id="aaf8c218d42e3946e3aa8b2f60511809f" name="aaf8c218d42e3946e3aa8b2f60511809f"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:aaf8c218d42e3946e3aa8b2f60511809f template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_mut_v</b> = <a class="el" href="structgaia_1_1core_1_1detail_1_1is__mut.html">detail::is_mut</a>&lt;T&gt;::value</td></tr>
<tr class="memitem:ac472cf2aff79e36c77ced213104c99ff" id="r_ac472cf2aff79e36c77ced213104c99ff"><td class="memTemplParams" colspan="2"><a id="ac472cf2aff79e36c77ced213104c99ff" name="ac472cf2aff79e36c77ced213104c99ff"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ac472cf2aff79e36c77ced213104c99ff template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_raw_v</b> = std::is_same_v&lt;T, raw_t&lt;T&gt;&gt; &amp;&amp; !std::is_array_v&lt;T&gt;</td></tr>
<tr class="memitem:a2a51917fa9823ba346fdc3e633a8545c" id="r_a2a51917fa9823ba346fdc3e633a8545c"><td class="memTemplParams" colspan="2"><a id="a2a51917fa9823ba346fdc3e633a8545c" name="a2a51917fa9823ba346fdc3e633a8545c"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a2a51917fa9823ba346fdc3e633a8545c template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_complete_v</b> = <a class="el" href="structgaia_1_1core_1_1detail_1_1is__complete.html">detail::is_complete</a>&lt;T&gt;::value</td></tr>
<tr class="memitem:ae6f69d49bf12819574469a0394f87ec9" id="r_ae6f69d49bf12819574469a0394f87ec9"><td class="memTemplParams" colspan="2"><a id="ae6f69d49bf12819574469a0394f87ec9" name="ae6f69d49bf12819574469a0394f87ec9"></a>
template&lt;typename...&gt; </td></tr>
<tr class="memitem:ae6f69d49bf12819574469a0394f87ec9 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>is_unique</b> = std::true_type{}</td></tr>
<tr class="memitem:a1f31983430c0033d2033058ac449faa7" id="r_a1f31983430c0033d2033058ac449faa7"><td class="memTemplParams" colspan="2">template&lt;typename T, typename... Rest&gt; </td></tr>
<tr class="memitem:a1f31983430c0033d2033058ac449faa7 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f31983430c0033d2033058ac449faa7">is_unique&lt; T, Rest... &gt;</a></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ad09aa617fbd787a173b3d4ca2f742ba6" name="ad09aa617fbd787a173b3d4ca2f742ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09aa617fbd787a173b3d4ca2f742ba6">&#9670;&#160;</a></span>addressof()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * gaia::core::addressof </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the actual address of the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>or function arg, even in presence of overloaded operator&amp;. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0addcb0ec5043a16a9cfbf3349f7d8f6" name="a0addcb0ec5043a16a9cfbf3349f7d8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0addcb0ec5043a16a9cfbf3349f7d8f6">&#9670;&#160;</a></span>call_ctor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::call_ctor </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>pData</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an object of type <em class="arg">T</em> at the given memory address. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to construct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>Pointer to the memory where the object should be constructed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>pData must not be nullptr. </dd></dl>

</div>
</div>
<a id="a34727fe8a5b09c2c8bf5bfc65e890f22" name="a34727fe8a5b09c2c8bf5bfc65e890f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34727fe8a5b09c2c8bf5bfc65e890f22">&#9670;&#160;</a></span>call_ctor_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::call_ctor_n </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>pData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>cnt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs <em class="arg">cnt</em> objects of type <em class="arg">T</em> at the memory address <em class="arg">pData</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to construct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>Pointer to where the object will be constructed; must not be null. </td></tr>
    <tr><td class="paramname">cnt</td><td>Number of objects to construct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac63132486ad640dc568185efb6f86bf" name="aac63132486ad640dc568185efb6f86bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac63132486ad640dc568185efb6f86bf">&#9670;&#160;</a></span>call_ctor_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::call_ctor_raw </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>pData</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an object of type <em class="arg">T</em> in the uninitialized storage at the memory address <em class="arg">pData</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to construct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>Pointer to where the object will be constructed; must not be null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa62b150418f1c4b5a39fb0f3ca0caad" name="afa62b150418f1c4b5a39fb0f3ca0caad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa62b150418f1c4b5a39fb0f3ca0caad">&#9670;&#160;</a></span>call_ctor_raw_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::call_ctor_raw_n </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>pData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>cnt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs <em class="arg">cnt</em> objects of type <em class="arg">T</em> in the uninitialized storage at the memory address <em class="arg">pData</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to construct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>Pointer to where the object will be constructed; must not be null. </td></tr>
    <tr><td class="paramname">cnt</td><td>Number of objects to construct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a295df67d6d1d214c7f1ba4811653908f" name="a295df67d6d1d214c7f1ba4811653908f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295df67d6d1d214c7f1ba4811653908f">&#9670;&#160;</a></span>call_ctor_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::call_ctor_val </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>pData</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value-constructs an object of type <em class="arg">T</em> in the uninitialized storage at the memory address <em class="arg">pData</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to construct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>Pointer to where the object will be constructed; must not be null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ac59173e286302735c343d2203f72bc" name="a3ac59173e286302735c343d2203f72bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac59173e286302735c343d2203f72bc">&#9670;&#160;</a></span>call_ctor_val_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::call_ctor_val_n </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>pData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>cnt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value-constructs <em class="arg">cnt</em> objects of type <em class="arg">T</em> in the uninitialized storage at the memory address <em class="arg">pData</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to construct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>Pointer to where the object will be constructed; must not be null. </td></tr>
    <tr><td class="paramname">cnt</td><td>Number of objects to construct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35ed5fc7e07b3d4ba9fa198d71762440" name="a35ed5fc7e07b3d4ba9fa198d71762440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ed5fc7e07b3d4ba9fa198d71762440">&#9670;&#160;</a></span>call_dtor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::call_dtor </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>pData</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructs an object of type <em class="arg">T</em> at the given memory address. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to destruct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>Pointer to the memory where the object should be destructed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>pData must not be nullptr. </dd></dl>

</div>
</div>
<a id="ad9c74703bee60369368d3132e617280c" name="ad9c74703bee60369368d3132e617280c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c74703bee60369368d3132e617280c">&#9670;&#160;</a></span>call_dtor_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::call_dtor_n </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>pData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>cnt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructs <em class="arg">cnt</em> objects of type <em class="arg">T</em> at the memory address <em class="arg">pData</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to construct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>Pointer to where the object will be destructed; must not be null. </td></tr>
    <tr><td class="paramname">cnt</td><td>Number of objects to construct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00878ab0e950060e7b2a404ce4346e05" name="a00878ab0e950060e7b2a404ce4346e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00878ab0e950060e7b2a404ce4346e05">&#9670;&#160;</a></span>each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Iters, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::each </td>
          <td>(</td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time for loop. Performs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iters</td><td>iterations.</td></tr>
  </table>
  </dd>
</dl>
<p>Example 1 (index argument): sarray&lt;int, 10&gt; arr = { ... }; <a class="el" href="#a00878ab0e950060e7b2a404ce4346e05" title="Compile-time for loop. Performs.">each&lt;arr.size()&gt;</a>([&amp;arr](auto i) { GAIA_LOG_N("%d", i); });</p>
<p>Example 2 (no index argument): uint32_t cnt = 0; each&lt;10&gt;([&amp;cnt]() { GAIA_LOG_N("Invocation number: %u", cnt++); }); </p>

</div>
</div>
<a id="a4bd577776f837fefab5ab7acf8dc0dab" name="a4bd577776f837fefab5ab7acf8dc0dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd577776f837fefab5ab7acf8dc0dab">&#9670;&#160;</a></span>each_ext() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto FirstIdx, auto LastIdx, auto Inc, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::each_ext </td>
          <td>(</td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time for loop with adjustable range and iteration size. Iteration starts at. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FirstIdx</td><td>and ends at </td></tr>
    <tr><td class="paramname">LastIdx</td><td>(excluding) at increments of </td></tr>
    <tr><td class="paramname">Inc.</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Example 1 (index argument): sarray&lt;int, 10&gt; arr; each_ext&lt;0, 10, 2&gt;([&amp;arr](auto i) { GAIA_LOG_N("%d", i); });</p>
<p>Example 2 (no argument): uint32_t cnt = 0; each_ext&lt;0, 10, 2&gt;([&amp;cnt]() { GAIA_LOG_N("Invocation number: %u", cnt++); }); </p>

</div>
</div>
<a id="a4acb645e18169c91361106ea0c3eca54" name="a4acb645e18169c91361106ea0c3eca54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acb645e18169c91361106ea0c3eca54">&#9670;&#160;</a></span>each_ext() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto FirstIdx, auto LastIdx, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::each_ext </td>
          <td>(</td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time for loop with adjustable range. Iteration starts at. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FirstIdx</td><td>and ends at </td></tr>
    <tr><td class="paramname">LastIdx</td><td>(excluding).</td></tr>
  </table>
  </dd>
</dl>
<p>Example 1 (index argument): sarray&lt;int, 10&gt; arr; each_ext&lt;0, 10&gt;([&amp;arr](auto i) { GAIA_LOG_N("%d", i); });</p>
<p>Example 2 (no argument): uint32_t cnt = 0; each_ext&lt;0, 10&gt;([&amp;cnt]() { GAIA_LOG_N("Invocation number: %u", cnt++); }); </p>

</div>
</div>
<a id="a5a9456f790d80f3e355e86280a1c0018" name="a5a9456f790d80f3e355e86280a1c0018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9456f790d80f3e355e86280a1c0018">&#9670;&#160;</a></span>each_pack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::each_pack </td>
          <td>(</td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time for loop over parameter packs. </p>
<p>Example: template&lt;typename... Args&gt; void print(const Args&amp;... args) { each_pack([](const auto&amp; value) { std::cout &lt;&lt; value &lt;&lt; std::endl; }); } print(69, "likes", 420.0f); </p>

</div>
</div>
<a id="ad4cb6904c9e9ec556c0e1a2f2248e5c7" name="ad4cb6904c9e9ec556c0e1a2f2248e5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cb6904c9e9ec556c0e1a2f2248e5c7">&#9670;&#160;</a></span>each_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::each_tuple </td>
          <td>(</td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time for loop over tuples and other objects implementing tuple_size (sarray, std::pair etc). </p>
<dl class="section warning"><dt>Warning</dt><dd>This does not use a tuple instance, only the type. Use for compile-time operations only.</dd></dl>
<p>Example: each_tuple( std::make_tuple(69, "likes", 420.0f), [](const auto&amp; value) { std::cout &lt;&lt; value &lt;&lt; std::endl; }); Output: 0 nullptr 0.0f </p>

</div>
</div>
<a id="a14f553e6938d7cebcdaaf2539dae439a" name="a14f553e6938d7cebcdaaf2539dae439a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f553e6938d7cebcdaaf2539dae439a">&#9670;&#160;</a></span>each_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::each_tuple </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>tuple</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time for loop over tuples and other objects implementing tuple_size (sarray, std::pair etc). </p>
<p>Example: each_tuple( std::make_tuple(69, "likes", 420.0f), [](const auto&amp; value) { std::cout &lt;&lt; value &lt;&lt; std::endl; }); Output: 69 likes 420.0f </p>

</div>
</div>
<a id="ad49ddfc3b59c778b9982d66adfe13a1e" name="ad49ddfc3b59c778b9982d66adfe13a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49ddfc3b59c778b9982d66adfe13a1e">&#9670;&#160;</a></span>each_tuple_ext() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto FirstIdx, auto LastIdx, typename Tuple, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::each_tuple_ext </td>
          <td>(</td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time for loop over tuples and other objects implementing tuple_size (sarray, std::pair etc). Iteration starts at. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FirstIdx</td><td>and ends at </td></tr>
    <tr><td class="paramname">LastIdx</td><td>(excluding). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This does not use a tuple instance, only the type. Use for compile-time operations only.</dd></dl>
<p>Example: each_tuple( 1, 3, std::make_tuple(69, "likes", 420.0f), [](const auto&amp; value) { std::cout &lt;&lt; value &lt;&lt; std::endl; }); Output: nullptr 0.0f </p>

</div>
</div>
<a id="ac417c3dccaae72ead9a3448a584fd63b" name="ac417c3dccaae72ead9a3448a584fd63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac417c3dccaae72ead9a3448a584fd63b">&#9670;&#160;</a></span>each_tuple_ext() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto FirstIdx, auto LastIdx, typename Tuple, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::each_tuple_ext </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>tuple</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time for loop over tuples and other objects implementing tuple_size (sarray, std::pair etc). Iteration starts at. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FirstIdx</td><td>and ends at </td></tr>
    <tr><td class="paramname">LastIdx</td><td>(excluding).</td></tr>
  </table>
  </dd>
</dl>
<p>Example: each_tuple_ext&lt;1, 3&gt;( std::make_tuple(69, "likes", 420.0f), [](const auto&amp; value) { std::cout &lt;&lt; value &lt;&lt; std::endl; }); Output: likes 420.0f </p>

</div>
</div>
<a id="a6b8e474fbd36fcc7f89a908107e9fbc1" name="a6b8e474fbd36fcc7f89a908107e9fbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8e474fbd36fcc7f89a908107e9fbc1">&#9670;&#160;</a></span>quick_sort_stack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename TCmpFunc, typename TSwapFunc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::quick_sort_stack </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>high</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCmpFunc</td>          <td class="paramname"><span class="paramname"><em>cmpFunc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSwapFunc</td>          <td class="paramname"><span class="paramname"><em>swapFunc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>maxStackSize</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A special version of the quick sort algorithm. Instead of relying on recursion it allocates an acceleration structure on the stack. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>Container to sort </td></tr>
    <tr><td class="paramname">TCmpFunc</td><td>Comparison function </td></tr>
    <tr><td class="paramname">TSwapFunc</td><td>Swap function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Container to sort </td></tr>
    <tr><td class="paramname">low</td><td>Low index of the array to sort </td></tr>
    <tr><td class="paramname">high</td><td>High index of the array to sort </td></tr>
    <tr><td class="paramname">cmpFunc</td><td>Comparison function </td></tr>
    <tr><td class="paramname">swapFunc</td><td>Swap function </td></tr>
    <tr><td class="paramname">maxStackSize</td><td>Maximum depth of the stack used for the acceleration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the input container is larger than <em class="arg">maxStackSize</em> the function might end up accessing memory out-of-bounds. This would usually happen e.g. when sorting an already sorted array. This is because you can not easily predict the depth of the stack used by the algorithm. </dd></dl>

</div>
</div>
<a id="a4d9686a728c1ca30ff83a8f5808af340" name="a4d9686a728c1ca30ff83a8f5808af340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9686a728c1ca30ff83a8f5808af340">&#9670;&#160;</a></span>quick_sort_stack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename TCmpFunc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::quick_sort_stack </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>high</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCmpFunc</td>          <td class="paramname"><span class="paramname"><em>cmpFunc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>maxStackSize</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A special version of the quick sort algorithm. Instead of relying on recursion it allocates an acceleration structure on the stack. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>Container to sort </td></tr>
    <tr><td class="paramname">TCmpFunc</td><td>Comparison function </td></tr>
    <tr><td class="paramname">TSwapFunc</td><td>Swap function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Container to sort </td></tr>
    <tr><td class="paramname">low</td><td>Low index of the array to sort </td></tr>
    <tr><td class="paramname">high</td><td>High index of the array to sort </td></tr>
    <tr><td class="paramname">cmpFunc</td><td>Comparison function </td></tr>
    <tr><td class="paramname">maxStackSize</td><td>Maximum depth of the stack used for the acceleration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the input container is larger than <em class="arg">maxStackSize</em> the function might end up accessing memory out-of-bounds. This would usually happen e.g. when sorting an already sorted array. This is because you can not easily predict the depth of the stack used by the algorithm. </dd></dl>

</div>
</div>
<a id="a750a65f7b8957f39c44de8126afc9a86" name="a750a65f7b8957f39c44de8126afc9a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750a65f7b8957f39c44de8126afc9a86">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TCmpFunc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::sort </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>beg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCmpFunc</td>          <td class="paramname"><span class="paramname"><em>cmpFunc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a range of elements. Sorting network is used up to 8 elements. Bubble-sort is used up to 32 elements. For anything else, quicksort is used. Use when it is necessary to sort multiple arrays at once. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
    <tr><td class="paramname">TCmpFunc</td><td>Functor type for comparison: bool cmpFunc(i, j) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Pointer to first element </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to one-past-last element </td></tr>
    <tr><td class="paramname">cmpFunc</td><td>Comparision function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb0855ba2c1593cdd5657d226b8af722" name="acb0855ba2c1593cdd5657d226b8af722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0855ba2c1593cdd5657d226b8af722">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TCmpFunc, typename TSwapFunc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::sort </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>beg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCmpFunc</td>          <td class="paramname"><span class="paramname"><em>cmpFunc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSwapFunc</td>          <td class="paramname"><span class="paramname"><em>swapFunc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a range of elements given a comparison function <em class="arg">cmpFunc</em>. If <em class="arg">cmpFunc</em> returns true it performs <em class="arg">swapFunc</em> which can perform the sorting. Sorting network is used up to 8 elements. Bubble-sort is used up to 32 elements. For anything else, quicksort is used. Use when it is necessary to sort multiple arrays at once. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
    <tr><td class="paramname">TCmpFunc</td><td>Functor type for comparison: bool cmpFunc(i, j) </td></tr>
    <tr><td class="paramname">TSwapFunc</td><td>Functor type for swapping: void swapFunc(i, j) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Pointer to first element </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to one-past-last element </td></tr>
    <tr><td class="paramname">cmpFunc</td><td>Comparision function </td></tr>
    <tr><td class="paramname">swapFunc</td><td>Sorting function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4243d49bb085eeae237b6330b9e76bd1" name="a4243d49bb085eeae237b6330b9e76bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4243d49bb085eeae237b6330b9e76bd1">&#9670;&#160;</a></span>swap_erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::swap_erase </td>
          <td>(</td>
          <td class="paramtype">C &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename C::size_type</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the item at <em class="arg">idx</em> in the array <em class="arg">arr</em> with the last item of the array if possible and removes its last item. Use when shifting of the entire array is not wanted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array </td></tr>
    <tr><td class="paramname">idx</td><td>Array index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the item order is important and the size of the array changes after calling this function you need </dd></dl>

</div>
</div>
<a id="a5cca46165fa888f2b19201daff21fd10" name="a5cca46165fa888f2b19201daff21fd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cca46165fa888f2b19201daff21fd10">&#9670;&#160;</a></span>swap_erase_unsafe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::swap_erase_unsafe </td>
          <td>(</td>
          <td class="paramtype">C &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename C::size_type</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the item at <em class="arg">idx</em> in the array <em class="arg">arr</em> with the last item of the array if possible and removes its last item. Use when shifting of the entire array is not wanted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array </td></tr>
    <tr><td class="paramname">idx</td><td>Array index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the item order is important and the size of the array changes after calling this function you need to sort the array. </dd>
<dd>
Does not do bound checks. Undefined behavior when <em class="arg">idx</em> is out of bounds. </dd></dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a858d3a926731f0fae03f91a8fc9d3722" name="a858d3a926731f0fae03f91a8fc9d3722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858d3a926731f0fae03f91a8fc9d3722">&#9670;&#160;</a></span>is_bidi_iter_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gaia::core::is_bidi_iter_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        std::is_convertible_v&lt;detail::iterator_cat_t&lt;It&gt;, <a class="code hl_struct" href="structgaia_1_1core_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a>&gt;</div>
<div class="ttc" id="astructgaia_1_1core_1_1bidirectional__iterator__tag_html"><div class="ttname"><a href="structgaia_1_1core_1_1bidirectional__iterator__tag.html">gaia::core::bidirectional_iterator_tag</a></div><div class="ttdef"><b>Definition</b> iterator.h:14</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a13a0e5893d2992e75035ea1b0eec9248" name="a13a0e5893d2992e75035ea1b0eec9248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a0e5893d2992e75035ea1b0eec9248">&#9670;&#160;</a></span>is_fwd_iter_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gaia::core::is_fwd_iter_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        std::is_convertible_v&lt;detail::iterator_cat_t&lt;It&gt;, <a class="code hl_struct" href="structgaia_1_1core_1_1forward__iterator__tag.html">forward_iterator_tag</a>&gt;</div>
<div class="ttc" id="astructgaia_1_1core_1_1forward__iterator__tag_html"><div class="ttname"><a href="structgaia_1_1core_1_1forward__iterator__tag.html">gaia::core::forward_iterator_tag</a></div><div class="ttdef"><b>Definition</b> iterator.h:12</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a386b8abad014ad2733222e8f31b2339f" name="a386b8abad014ad2733222e8f31b2339f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386b8abad014ad2733222e8f31b2339f">&#9670;&#160;</a></span>is_input_iter_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gaia::core::is_input_iter_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        std::is_convertible_v&lt;detail::iterator_cat_t&lt;It&gt;, <a class="code hl_struct" href="structgaia_1_1core_1_1input__iterator__tag.html">input_iterator_tag</a>&gt;</div>
<div class="ttc" id="astructgaia_1_1core_1_1input__iterator__tag_html"><div class="ttname"><a href="structgaia_1_1core_1_1input__iterator__tag.html">gaia::core::input_iterator_tag</a></div><div class="ttdef"><b>Definition</b> iterator.h:9</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a91cf58b531e633cd06585bc2ff77ad73" name="a91cf58b531e633cd06585bc2ff77ad73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cf58b531e633cd06585bc2ff77ad73">&#9670;&#160;</a></span>is_random_iter_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gaia::core::is_random_iter_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        std::is_convertible_v&lt;detail::iterator_cat_t&lt;It&gt;, <a class="code hl_struct" href="structgaia_1_1core_1_1random__access__iterator__tag.html">random_access_iterator_tag</a>&gt;</div>
<div class="ttc" id="astructgaia_1_1core_1_1random__access__iterator__tag_html"><div class="ttname"><a href="structgaia_1_1core_1_1random__access__iterator__tag.html">gaia::core::random_access_iterator_tag</a></div><div class="ttdef"><b>Definition</b> iterator.h:15</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a282cfebb703ebbe76d8d8c1e740906b4" name="a282cfebb703ebbe76d8d8c1e740906b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282cfebb703ebbe76d8d8c1e740906b4">&#9670;&#160;</a></span>is_rev_iter_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gaia::core::is_rev_iter_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        std::is_convertible_v&lt;detail::iterator_cat_t&lt;It&gt;, <a class="code hl_struct" href="structgaia_1_1core_1_1reverse__iterator__tag.html">reverse_iterator_tag</a>&gt;</div>
<div class="ttc" id="astructgaia_1_1core_1_1reverse__iterator__tag_html"><div class="ttname"><a href="structgaia_1_1core_1_1reverse__iterator__tag.html">gaia::core::reverse_iterator_tag</a></div><div class="ttdef"><b>Definition</b> iterator.h:13</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f31983430c0033d2033058ac449faa7" name="a1f31983430c0033d2033058ac449faa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f31983430c0033d2033058ac449faa7">&#9670;&#160;</a></span>is_unique&lt; T, Rest... &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename... Rest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gaia::core::is_unique&lt; T, Rest... &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        std::bool_constant&lt;(!std::is_same_v&lt;T, Rest&gt; &amp;&amp; ...) &amp;&amp; is_unique&lt;Rest...&gt;&gt;{}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacegaia.html">gaia</a></li><li class="navelem"><a href="namespacegaia_1_1core.html">core</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
