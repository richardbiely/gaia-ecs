<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gaia-ECS: Gaia-ECS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">Gaia-ECS<span id="projectnumber">&#160;v0.9.3</span>
   </div>
   <div id="projectbrief">A simple and powerful entity component system</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Gaia-ECS </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2gaia-ecs_2gaia-ecs_2README"></a> <img src="logo.png" alt="" class="inline" title="gaia-ecs"/>    </p>
<p><a href="https://github.com/richardbiely/gaia-ecs/releases"><img src="https://img.shields.io/github/v/release/richardbiely/gaia-ecs?style=for-the-badge" alt="Version" class="inline"/></a> <a href="https://en.wikipedia.org/wiki/MIT_License"><img src="https://img.shields.io/badge/license-MIT-blue?style=for-the-badge" alt="license" class="inline"/></a> <a href="https://en.wikipedia.org/wiki/C%2B%2B17"><img src="https://img.shields.io/badge/language-C%2B%2B17-yellow?style=for-the-badge&amp;color=blue" alt="language" class="inline"/></a> <a href="https://discord.gg/wJjK72yze2"><img src="https://img.shields.io/discord/1183706605108330516?style=for-the-badge&amp;label=Discord" alt="discord" class="inline"/></a> <a href="https://app.codacy.com/gh/richardbiely/gaia-ecs/dashboard?utm_source=gh&amp;utm_medium=referral&amp;utm_content=&amp;utm_campaign=Badge_grade"><img src="https://img.shields.io/codacy/grade/bb28fa362fce4054bbaf7a6ba9aed140?style=for-the-badge" alt="codacy" class="inline"/></a></p>
<p><a href="https://richardbiely.github.io/gaia-ecs/"><img src="https://img.shields.io/badge/docs-doxygen-blue?style=for-the-badge" alt="Documentation" class="inline"/></a></p>
<p><b>Gaia-ECS</b> is a fast and easy-to-use <a class="el" href="index.html#ecs">ECS</a> framework. Some of its current features and highlights are:</p><ul>
<li>very simple and safe API</li>
<li>based on <a href="https://en.cppreference.com/w/cpp/17">C++17</a> with no external dependencies (no STL strings or containers)</li>
<li>compiles warning-free on <a href="https://github.com/richardbiely/gaia-ecs/actions">all major compilers</a></li>
<li>archetype / chunk-based storage for maximum iteration speed and easy code parallelization</li>
<li>supports applications with large number of components and archetypes</li>
<li>can be compiled to run in a web browser using <a href="https://emscripten.org">Emscripten</a></li>
<li>automatic component registration</li>
<li>supports <a class="el" href="index.html#create-or-delete-entity">run-time defined tags</a></li>
<li>supports <a class="el" href="index.html#relationships">entity relationships</a></li>
<li>supports smart pointer-like <a class="el" href="index.html#entity-lifespan">entity lifespan</a> management</li>
<li>integrated both <a class="el" href="index.html#compile-time-serialization">compile-time</a> and <a class="el" href="index.html#runtime-serialization">runtime</a> serialization</li>
<li>comes with <a class="el" href="index.html#multithreading">multithreading</a> support with job-dependencies, supported on the <a class="el" href="index.html#parallel-execution">ECS level</a>, too</li>
<li>ability to <a class="el" href="index.html#data-layouts">organize data as AoS or SoA</a> on the component level with very few changes to your code</li>
<li>compiles almost instantly</li>
<li>stability and correctness ensured by thousands of <a class="el" href="index.html#testing">unit tests</a>, in-code asserts, and sanitizers</li>
<li>thoroughly documented both public and internal code</li>
<li>exists also as a <a class="el" href="index.html#single-header">single-header</a> library so you can simply drop it into your project and start using it</li>
</ul>
<p>NOTE: Due to its extensive use of acceleration structures and caching, this library is not a good fit for hardware with very limited memory resources (measured in MiBs or less). Micro-controllers, retro gaming consoles, and similar platforms should consider alternative solutions.</p>
<h1><a class="anchor" id="table-of-contents"></a>
Table of Contents</h1>
<ul>
<li><a class="el" href="index.html#introduction">Introduction</a><ul>
<li><a class="el" href="index.html#ecs">ECS</a></li>
<li><a class="el" href="index.html#implementation">Implementation</a></li>
<li><a class="el" href="index.html#project-structure">Project structure</a></li>
</ul>
</li>
<li><a class="el" href="index.html#usage">Usage</a><ul>
<li><a class="el" href="index.html#minimum-requirements">Minimum requirements</a></li>
<li><a class="el" href="index.html#basic-operations">Basic operations</a><ul>
<li><a class="el" href="index.html#create-or-delete-entity">Create or delete entity</a></li>
<li><a class="el" href="index.html#name-entity">Name entity</a></li>
<li><a class="el" href="index.html#add-or-remove-component">Add or remove component</a></li>
<li><a class="el" href="index.html#component-presence">Component presence</a></li>
<li><a class="el" href="index.html#component-hooks">Component hooks</a></li>
<li><a class="el" href="index.html#bulk-editing">Bulk editing</a></li>
<li><a class="el" href="index.html#set-or-get-component-value">Set or get component value</a></li>
<li><a class="el" href="index.html#copy-entity">Copy entity</a></li>
<li><a class="el" href="index.html#entity-cleanup">Entity cleanup</a></li>
<li><a class="el" href="index.html#batched-creation">Batched creation</a></li>
<li><a class="el" href="index.html#entity-lifespan">Entity lifespan</a></li>
<li><a class="el" href="index.html#archetype-lifespan">Archetype lifespan</a></li>
</ul>
</li>
<li><a class="el" href="index.html#data-processing">Data processing</a><ul>
<li><a class="el" href="index.html#query">Query</a></li>
<li><a class="el" href="index.html#uncached-query">Uncached query</a></li>
<li><a class="el" href="index.html#iteration">Iteration</a></li>
<li><a class="el" href="index.html#constraints">Constraints</a></li>
<li><a class="el" href="index.html#change-detection">Change detection</a></li>
<li><a class="el" href="index.html#grouping">Grouping</a></li>
<li><a class="el" href="index.html#sorting">Sorting</a></li>
<li><a class="el" href="index.html#parallel-execution">Parallel execution</a></li>
</ul>
</li>
<li><a class="el" href="index.html#relationships">Relationships</a><ul>
<li><a class="el" href="index.html#relationship-basics">Relationship basics</a></li>
<li><a class="el" href="index.html#entity-dependencies">Entity dependencies</a></li>
<li><a class="el" href="index.html#combination-constraints">Combination constraints</a></li>
<li><a class="el" href="index.html#exclusivity">Exclusivity</a></li>
<li><a class="el" href="index.html#entity-inheritance">Entity inheritance</a></li>
<li><a class="el" href="index.html#targets">Targets</a></li>
<li><a class="el" href="index.html#relations">Relations</a></li>
<li><a class="el" href="index.html#cleanup-rules">Cleanup rules</a></li>
</ul>
</li>
<li><a class="el" href="index.html#unique-components">Unique components</a></li>
<li><a class="el" href="index.html#delayed-execution">Delayed execution</a><ul>
<li><a class="el" href="index.html#command-merging-rules">Command Merging rules</a></li>
</ul>
</li>
<li><a class="el" href="index.html#systems">Systems</a><ul>
<li><a class="el" href="index.html#system-basics">System basics</a></li>
<li><a class="el" href="index.html#system-dependencies">System dependencies</a></li>
<li><a class="el" href="index.html#system-jobs">Systems and jobs</a></li>
</ul>
</li>
<li><a class="el" href="index.html#data-layouts">Data layouts</a></li>
<li><a class="el" href="index.html#serialization">Serialization</a><ul>
<li><a class="el" href="index.html#compile-time-serialization">Compile-time serialization</a></li>
<li><a class="el" href="index.html#runtime-serialization">Runtime serialization</a></li>
<li><a class="el" href="index.html#world-serialization">World serialization</a></li>
</ul>
</li>
<li><a class="el" href="index.html#multithreading">Multithreading</a><ul>
<li><a class="el" href="index.html#jobs">Jobs</a></li>
<li><a class="el" href="index.html#job-dependencies">Job dependencies</a></li>
<li><a class="el" href="index.html#priorities">Priorities</a></li>
<li><a class="el" href="index.html#threads">Threads</a></li>
</ul>
</li>
<li><a class="el" href="index.html#customization">Customization</a><ul>
<li><a class="el" href="index.html#logging">Logging</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="index.html#requirements">Requirements</a><ul>
<li><a class="el" href="index.html#compiler">Compiler</a></li>
<li><a class="el" href="index.html#dependencies">Dependencies</a></li>
</ul>
</li>
<li><a class="el" href="index.html#installation">Installation</a><ul>
<li><a class="el" href="index.html#cmake">CMake</a><ul>
<li><a class="el" href="index.html#project-settings">Project settings</a></li>
<li><a class="el" href="index.html#sanitizers">Sanitizers</a></li>
<li><a class="el" href="index.html#single-header">Single-header</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="index.html#repository-structure">Repository structure</a><ul>
<li><a class="el" href="index.html#examples">Examples</a></li>
<li><a class="el" href="index.html#benchmarks">Benchmarks</a></li>
<li><a class="el" href="index.html#profiling">Profiling</a></li>
<li><a class="el" href="index.html#testing">Testing</a></li>
<li><a class="el" href="index.html#documentation">Documentation</a></li>
</ul>
</li>
<li><a class="el" href="index.html#future">Future</a></li>
<li><a class="el" href="index.html#contributions">Contributions</a></li>
<li><a class="el" href="index.html#license">License</a></li>
</ul>
<h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<h2><a class="anchor" id="ecs"></a>
ECS</h2>
<p><a href="https://en.wikipedia.org/wiki/Entity_component_system">Entity-Component-System (ECS)</a> is a software architectural pattern based on organizing your code around data which follows the principle of <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">composition over inheritance</a>. <br  />
</p>
<p>Instead of looking at "items" in your program as objects you normally know from the real world (car, house, human) you look at them as pieces of data necessary for you to achieve some result.</p>
<p>This way of thinking is more natural for machines than people but when used correctly it allows you to write faster code (on most architectures). What is most important, however, is it allows you to write code that is easier to maintain, expand and reason about.</p>
<p>For instance, when moving an object from point A to point B you do not care if it is a house or a car. You only care about its position. If you want to move it at some specific speed you will consider also the object's velocity. Nothing else is necessary.</p>
<p>Three building blocks of ECS are:</p><ul>
<li><b>Entity</b> (id) - an index that uniquely identifies a group of components</li>
<li><b>Component</b> (data) - a piece of data (position, velocity, age)</li>
<li><b>System</b> (processor) - a place where your program's logic is implemented</li>
</ul>
<p>Following the example given above, a vehicle could be any entity with Position and Velocity components. If it is a car we could attach the Driving component to it. If it is an airplane we would attach the Flying component.<br  />
 The actual movement is handled by <a class="el" href="index.html#systems">systems</a>. Those that match the Flying component will implement the logic for flying. Systems matching the Driving component handle the land movement.</p>
<p>On the outside ECS is not much different from database engines. The main difference is it does not need to follow the <a href="https://en.wikipedia.org/wiki/ACID">ACID</a> principle which allows it to be optimized beyond what an ordinary database engine could ever be both in terms of latency and absolute performance. At the cost of data safety.</p>
<p>The main strengths of an ECS done right could be summarized as:</p><ul>
<li><em>decoupling of logic</em> - separates data (components) from logic (systems)</li>
<li><em>modularity and reusability</em> - promotes modular and reusable code with self-contained components</li>
<li><em>ease of maintenance</em> - promotes less spaghetti code with a modular structure that is easier to debug</li>
<li><em>flexibility</em> - allows dynamic object behavior through composition of entities with specific components</li>
<li><em>adaptability</em> - easily adapts to changing project requirements through component and system modifications</li>
<li><em>performance</em> - optimized for data locality, supports data- and thread-level parallelism almost out-of-the-box; scales well with a predictable performance impact as the number of entities increases</li>
</ul>
<h2><a class="anchor" id="implementation"></a>
Implementation</h2>
<p><b>Gaia-ECS</b> is an archetype-based entity component system. This means that unique combinations of components are grouped into archetypes. Each archetype consists of chunks - blocks of memory holding your entities and components. You can think of them as <a href="https://en.wikipedia.org/wiki/Table_(database)">database tables</a> where components are columns and entities are rows.</p>
<p>Each chunk is either 8 or 16 KiB big depending on how much data can be effectively used by it. This size is chosen so that the entire chunk at its fullest can fit into the L1 cache on most CPUs. Chunk memory is preallocated in blocks organized into pages via the internal chunk allocator.</p>
<p>Components of the same type are grouped together and laid out linearly in memory. Thanks to all that data is organized in a cache-friendly way which most computer architectures like and actual heap allocations which are slow are reduced to a minimum.</p>
<p>The main benefits of archetype-based architecture are fast iteration and good memory layout by default. They are also easy to parallelize.</p>
<p>On the other hand, adding and removing components can be somewhat slower because it involves moving data around. In our case, this weakness is mitigated by building an archetype graph and having the ability to add and remove components in batches.</p>
<p>In this project, components are entities with the <em><b>Component</b></em> component attached to them. Treating components as entities allows for great design simplification and big features.</p>
<h2><a class="anchor" id="project-structure"></a>
Project structure</h2>
<p>The entire project is implemented inside gaia <em><b>namespace</b></em>. It is further split into multiple sub-projects each with a separate namespaces.</p><ul>
<li><em><b>core</b></em> - core functionality, use by all other parts of the code</li>
<li><em><b>mem</b></em> - memory-related operations, memory allocators</li>
<li><em><b>cnt</b></em> - data containers</li>
<li><em><b>meta</b></em> - reflection framework</li>
<li><em><b>ser</b></em> - serialization framework</li>
<li><em><b>mt</b></em> - multithreading framework</li>
<li><em><b>ecs</b></em> - the ECS part of the project</li>
</ul>
<p>The project has a dedicated <em><b>external</b></em> section that contains 3rd-party code. At present, it only includes a modified version of the <a href="https://github.com/martinus/robin-hood-hashing">robin-hood</a> hash-map.</p>
<h1><a class="anchor" id="usage"></a>
Usage</h1>
<h2><a class="anchor" id="minimum-requirements"></a>
Minimum requirements</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gaia.h&gt;</span></div>
</div><!-- fragment --><p>The entire framework is placed in a namespace called <b>gaia</b>. The ECS part of the library is found under <b>gaia::ecs</b> namespace.<br  />
 In the code examples below we will assume we are inside gaia namespace.</p>
<h2><a class="anchor" id="basic-operations"></a>
Basic operations</h2>
<h3><a class="anchor" id="create-or-delete-entity"></a>
Create or delete entity</h3>
<p>Entity a unique "thing" in <em><b>World</b></em>. Creating an entity at runtime is as easy as calling <em><b>World::add</b></em>. Deleting is done via <em><b>World::del</b></em>. Once deleted, entity is no longer valid and if used with some APIs it is going to trigger a debug-mode assert. Verifying that an entity is valid can be done by calling <em><b>World::valid</b></em>.</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line"><span class="comment">// Create a new entity</span></div>
<div class="line">ecs::Entity e = w.add();</div>
<div class="line"><span class="comment">// Check if &quot;e&quot; is valid. Returns true.</span></div>
<div class="line"><span class="keywordtype">bool</span> isValid = w.valid(e); <span class="comment">// true</span></div>
<div class="line"><span class="comment">// Delete the entity</span></div>
<div class="line">w.del(e);</div>
<div class="line"><span class="comment">// Check if &quot;e&quot; is still valid. Return false.</span></div>
<div class="line">isValid = w.valid(e); <span class="comment">// false</span></div>
</div><!-- fragment --><p>It is also possible to attach entities to entities. This effectively means you are able to create your own components/tags at runtime.</p>
<div class="fragment"><div class="line">ecs::Entity player0 = w.add();</div>
<div class="line">ecs::Entity player1 = w.add();</div>
<div class="line">ecs::Entity player2 = w.add();</div>
<div class="line">ecs::Entity teamA = w.add();</div>
<div class="line">ecs::Entity teamB = w.add();</div>
<div class="line"><span class="comment">// Add player0 and player1 to teamA</span></div>
<div class="line">w.add(player0, teamA);</div>
<div class="line">w.add(player1, teamA);</div>
<div class="line"><span class="comment">// Add player2 to teamB</span></div>
<div class="line">w.add(player2, teamB);</div>
</div><!-- fragment --><h3><a class="anchor" id="name-entity"></a>
Name entity</h3>
<p>Each entity can be assigned a unique name. This is useful for debugging or entity lookup when entity id is not present for any reason.</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line">ecs::Entity e = w.add();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Entity &quot;e&quot; named &quot;my_unique_name&quot;.</span></div>
<div class="line"><span class="comment">// The string is copied and stored internally.</span></div>
<div class="line">w.name(e, <span class="stringliteral">&quot;my_unique_name&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If you know the length of the string, you can provide it as well</span></div>
<div class="line">w.name(e, <span class="stringliteral">&quot;my_unique_name&quot;</span>, 14);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pointer to the string used as entity name for entity &quot;e&quot;</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* name = w.name(e);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Entity identified by the string returned.</span></div>
<div class="line"><span class="comment">// In this case, &quot;e_by_name&quot; and &quot;e&quot; are equal.</span></div>
<div class="line">ecs::Entity e_by_name = w.get(<span class="stringliteral">&quot;my_unique_name&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The name can be unset by setting it to nullptr</span></div>
<div class="line">w.name(e, <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p>If you already have a dedicated string storage it would be a waste to duplicate the memory. In this case you can use <em><b>World::name_raw</b></em> to name entities. It does NOT copy and does NOT store the string internally which means you are responsible for its lifetime. The pointer should be stable. Otherwise, any time your storage tries to move the string to a different place you have to unset the name before it happens and set it anew after the move is done.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* pUserManagedString = ...;</div>
<div class="line">w.name_raw(e, pUserManagedString);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If you now the length, you can provide it</span></div>
<div class="line">w.name_raw(e, pUserManagedString, userManagedStringLength);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If the user-managed string pointer is not stable, you need to unset the name before the pointer changes location</span></div>
<div class="line">w.name_raw(e, <span class="keyword">nullptr</span>);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// ... the change of pointer happens</span></div>
<div class="line">...</div>
<div class="line"><span class="comment">// After the user-managed string changed location and obtained a new pointer, you set the name again</span></div>
<div class="line">w.name_raw(e, pUserManagedString);</div>
</div><!-- fragment --><p>Hierarchical name lookup is also possible. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> europe = wld.add();</div>
<div class="line"><span class="keyword">auto</span> slovakia = wld.add();</div>
<div class="line"><span class="keyword">auto</span> bratislava = wld.add();</div>
<div class="line"> </div>
<div class="line">wld.child(slovakia, europe);</div>
<div class="line">wld.child(bratislava, slovakia);</div>
<div class="line"> </div>
<div class="line">wld.name(europe, <span class="stringliteral">&quot;europe&quot;</span>);</div>
<div class="line">wld.name(slovakia, <span class="stringliteral">&quot;slovakia&quot;</span>);</div>
<div class="line">wld.name(bratislava, <span class="stringliteral">&quot;bratislava&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> e1 = wld.get(<span class="stringliteral">&quot;europe.slovakia&quot;</span>); <span class="comment">// returns slovakia</span></div>
<div class="line"><span class="keyword">auto</span> e2 = wld.get(<span class="stringliteral">&quot;europe.slovakia.bratislava&quot;</span>); <span class="comment">// returns bratislava</span></div>
</div><!-- fragment --><p>Character '.' (dot) is used as a separator. Therefore, dots can not be used inside entity names. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> e = wld.add();</div>
<div class="line">wld.name(e, <span class="stringliteral">&quot;eur.ope&quot;</span>); <span class="comment">// invalid name, the naming request is going to be ignored</span></div>
</div><!-- fragment --><h3><a class="anchor" id="add-or-remove-component"></a>
Add or remove component</h3>
<p>Components can be created using <em><b>World::add&lt;T&gt;</b></em>. This function returns a descriptor of the object which is created and stored in the component cache. Each component is assigned one entity to uniquely identify it. You do not have to do this yourself, the framework performs this operation automatically behind the scenes any time you call some compile-time API where you interact with your structure. However, you can use this API to quickly fetch the component's entity if necessary.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Position {</div>
<div class="line">  <span class="keywordtype">float</span> x, y, z;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">const</span> ecs::ComponentCacheItem&amp; cci = w.add&lt;Position&gt;();</div>
<div class="line">ecs::Entity position_entity = cci.entity;</div>
</div><!-- fragment --><p>Because components are entities as well, adding them is very similar to what we have seen previously.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Position {</div>
<div class="line">  <span class="keywordtype">float</span> x, y, z;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>Velocity {</div>
<div class="line">  <span class="keywordtype">float</span> x, y, z;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">ecs::World w;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create an entity with Position and Velocity.</span></div>
<div class="line">ecs::Entity e = w.add();</div>
<div class="line">w.add&lt;Position&gt;(e, {0, 100, 0});</div>
<div class="line">w.add&lt;Velocity&gt;(e, {0, 0, 1});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Remove Velocity from the entity.</span></div>
<div class="line">w.del&lt;Velocity&gt;(e);</div>
</div><!-- fragment --><p>This also means the code above could be rewritten as following:</p>
<div class="fragment"><div class="line"><span class="comment">// Create Position and Velocity entities</span></div>
<div class="line">ecs::Entity position = w.add&lt;Position&gt;().entity;</div>
<div class="line">ecs::Entity velocity = w.add&lt;Velocity&gt;().entity;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create an entity with Position and Velocity.</span></div>
<div class="line">ecs::Entity e = w.add();</div>
<div class="line">w.add(e, position, Position{0, 100, 0});</div>
<div class="line">w.add(e, velocity, Velocity{0, 0, 1});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Remove Velocity from the entity.</span></div>
<div class="line">w.del(e, velocity);</div>
</div><!-- fragment --><p>When adding components following restrictions apply:</p><ul>
<li>There can be at most 32 components per entity. If you need more you can merge some of your components, or even rethink the strategy because too many components usually implies design issues (e.g. object-oriented thinking or using real-life abstractions when handling ECS entities and components).</li>
<li>Maximum size of a component is 4095 bytes. This is because internally chunks of 8 kiB or 16 kiB are used to store data. Therefore, components can not get too big. If this is not enough for you, inside your component you simply store a reference to data that you hold outside of ECS. Note, this restriction applies only to components stored in archetypes. In the future when more storage types are introduced this restriction won't apply to them.</li>
<li><a class="el" href="index.html#data-layouts">SoA</a> components can have at most 4 members and each of them can be at most 255 bytes long.</li>
<li>Components must be default-constructible (either the default constructor is present or you provide one yourself). If your component contains members that are not default-constructible (e.g. from a 3rd party library that is beyond your control), you need to work this around. You will need to store a pointer, or come up with different means of accessing this data.</li>
</ul>
<h3><a class="anchor" id="component-presence"></a>
Component presence</h3>
<p>Whether or not a certain component is associated with an entity can be checked in two different ways. Either via an instance of a World object or by the means of <em><b>Iter</b></em> which can be acquired when running <a class="el" href="index.html#query">queries</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Check if entity e has Velocity (via world).</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> hasVelocity = w.has&lt;Velocity&gt;(e);</div>
<div class="line"><span class="comment">// Check if entity wheel is attached to the car</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> hasWheel = w.has(car, wheel);</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check if entities hidden behind the iterator have Velocity (via iterator).</span></div>
<div class="line">ecs::Query q = w.query().any&lt;Position, Velocity&gt;(); </div>
<div class="line">q.each([&amp;](ecs::Iter&amp; it) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> hasPosition = it.has&lt;Position&gt;();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> hasVelocity = it.has&lt;Velocity&gt;();</div>
<div class="line">  ...</div>
<div class="line">});</div>
</div><!-- fragment --><p>Providing entities is supported as well.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> p = w.add&lt;Position&gt;().entity;</div>
<div class="line"><span class="keyword">auto</span> v = w.add&lt;Velocity&gt;().entity;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check if entities hidden behind the iterator have Velocity (via iterator).</span></div>
<div class="line">ecs::Query q = w.query().any(p).any(v); </div>
<div class="line">q.each([&amp;](ecs::Iter&amp; it) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> hasPosition = it.has(p);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> hasVelocity = it.has(v);</div>
<div class="line">  ...</div>
<div class="line">});</div>
</div><!-- fragment --><h3><a class="anchor" id="component-hooks"></a>
Component hooks</h3>
<p>It is possible to register add/del/set hooks for components. When a given component is added to an entity, deleted from it, or the value is set the hook triggers. This comes handy for debugging, or when specific logic is needed for a given component. Component hooks are unique. Each component can have at most one add hook, and one delete hook.</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line"><span class="keyword">const</span> ecs::ComponentCacheItem&amp; pos_item = w.add&lt;Position&gt;();</div>
<div class="line">ecs::ComponentCache::hooks(pos_item).func_add = [](<span class="keyword">const</span> ecs::World&amp; w, <span class="keyword">const</span> ecs::ComponentCacheItem&amp; cci, ecs::Entity src) {</div>
<div class="line">  <span class="comment">// Position component added to entity &quot;src&quot;</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">ecs::Entity e = w.add();</div>
<div class="line"><span class="comment">// The add hook will trigger</span></div>
<div class="line">w.add&lt;Position&gt;(e);</div>
</div><!-- fragment --><p>Hooks can easily be removed: </p><div class="fragment"><div class="line"><span class="keyword">const</span> ecs::ComponentCacheItem&amp; pos_item = w.add&lt;Position&gt;();</div>
<div class="line">ecs::ComponentCache::hooks(pos_item).func_add = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line">ecs::Entity e = w.add();</div>
<div class="line"><span class="comment">// The add hook will not be triggered because we removed the hook</span></div>
<div class="line">w.add&lt;Position&gt;(e);</div>
</div><!-- fragment --><p>It is also possible to set up a "set" hook. These are triggered whenever write access to component is requested. </p><div class="fragment"><div class="line">ecs::World w;</div>
<div class="line"><span class="keyword">const</span> ecs::ComponentCacheItem&amp; pos_item = w.add&lt;Position&gt;();</div>
<div class="line">ecs::ComponentCache::hooks(pos_item).func_set = [](<span class="keyword">const</span> ecs::World&amp; w, <span class="keyword">const</span> ecs::ComponentRecord&amp; rec, Chunk&amp; chunk) {</div>
<div class="line">  <span class="comment">// Position component value change has been requested</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">ecs::Entity e = w.add();</div>
<div class="line">w.add&lt;Position&gt;(e); <span class="comment">// Don&#39;t trigger the set hook, yet</span></div>
<div class="line">w.set&lt;Position&gt;(e) = {}; <span class="comment">// Trigger the set hook</span></div>
<div class="line">w.acc(e).set&lt;Position&gt;({}); <span class="comment">// Trigger the set hook</span></div>
<div class="line">w.acc(e).sset&lt;Position&gt;({}); <span class="comment">// Don&#39;t trigger the set hook</span></div>
</div><!-- fragment --><p>Unlike <em>add</em> and <em>del</em> hooks, <em>set</em> hooks will not tell you what entity the hook triggered for. This is because any write access is done for the entire chunk, not just one of its entities. If one-entity behavior is required, the best thing you can do is moving your entity to a separate archetype (e.g. by adding some unique tag component to it).</p>
<p>Hooks can be disabled by defining GAIA_ENABLE_HOOKS 0. Add and del hooks are controled by GAIA_ENABLE_ADD_DEL_HOOKS, set hooks by GAIA_ENABLE_SET_HOOKS. They are all enabled by default.</p>
<h3><a class="anchor" id="observers"></a>
Observers</h3>
<p>Observers are a mechanism that allows you to register to certain events and listen to them triggering. Similar to hooks, you can listen to add, del or set events. However, unlike hooks there can be any number of these per given component or entity.</p>
<p>Observers can be looked at as reactive alternative to systems. They allow different parts of the application to react to something happening immediately.</p>
<p>Under the hood they use the query engine, just like systems. However, systems are meant to be used as a reqular part of the frame whereas observers are meant as a reaction to something. Their cost is less predictable, and because the event needs to be evaluated for each observer, listening to the event they can also be more costly.</p>
<p>Following is an observer that generates an OnAdd event every time some entity is added Position and Velocity.</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line">w.observer()</div>
<div class="line">  .event(ObserverEvent::OnAdd)</div>
<div class="line">  .all&lt;Position&gt;()</div>
<div class="line">  .all&lt;Velocity&gt;()</div>
<div class="line">  .on_each([&amp;](ecs::Iter&amp; it) {</div>
<div class="line">    <span class="comment">// Called for each entity that has Position and Velocity added</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">ecs::Entity e = w.add();</div>
<div class="line"><span class="comment">// Observer will not trigger yet, only Position is added.</span></div>
<div class="line">w.add&lt;Position&gt;(e);</div>
<div class="line"><span class="comment">// Observer will trigger for the entity &quot;e&quot; now, because both Position and Velocity were added to it</span></div>
<div class="line">w.add&lt;Velocity&gt;(e);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Does not the observer for e1 when creating a copy. To do so, use copy_ext,</span></div>
<div class="line">ecs::Entity e1 = w.copy(e);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Triggers the observer for e2 because a new entity was created that is a copy of &quot;e&quot;, and has both Position and Velocity added.</span></div>
<div class="line">ecs::Entity e2 = w.copy_ext(e);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare a new entity &quot;e3&quot;.</span></div>
<div class="line">ecs::Entity e3 = w.add();</div>
<div class="line"><span class="comment">// We want to add Position and Velocity to &quot;e3&quot;. Our observer won&#39;t triggered yet because changes are not committed.</span></div>
<div class="line">ecs::EntityBuilder builder = w.build(e3);</div>
<div class="line">builder</div>
<div class="line">  .add&lt;Velocity&gt;()</div>
<div class="line">  .add&lt;Position&gt;();</div>
<div class="line"><span class="comment">// Commit changes. The observer will triggers now.</span></div>
<div class="line">builder.commit();</div>
</div><!-- fragment --><p>Listening to removal of entities looks similar: </p><div class="fragment"><div class="line">w.observer() <span class="comment">//</span></div>
<div class="line">  .event(ecs::ObserverEvent::OnDel)</div>
<div class="line">  .no&lt;Position&gt;()</div>
<div class="line">  .no&lt;Acceleration&gt;()</div>
<div class="line">  .on_each([&amp;cnt, &amp;isDel](ecs::Iter&amp; it) {</div>
<div class="line">    <span class="comment">// Called for each entity that has Position and Velocity removed from it</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Observer will not trigger yet, on Position was removed.</span></div>
<div class="line">w.del&lt;Position&gt;(e);</div>
<div class="line"><span class="comment">// Observer will trigger for the entity &quot;e&quot; now, because both Position and Velocity were removed from it</span></div>
<div class="line">w.del&lt;Velocity&gt;(e);</div>
</div><!-- fragment --><p>Observers can be enabled by defining GAIA_ENABLE_OBSERVERS 1. The feature is currently disabled by default.</p>
<h3><a class="anchor" id="bulk-editing"></a>
Bulk editing</h3>
<p>Adding an entity to entity means it becomes a part of a new archetype. Like mentioned <a class="el" href="index.html#implementation">previously</a>, becoming a part of a new archetype means that all data associated with the entity needs to be moved to a new place. The more ids in the archetype the slower the move (empty components/tags are an exception because they do not carry any data). For this reason it is not advised to perform large number of separate additions / removals per frame.</p>
<p>Instead, when adding or removing multiple entities/components at once it is more efficient doing it via bulk operations. This way only one archetype movement is performed in total rather than one per added/removed entity.</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create an entity with Position. This is one archetype movement.</span></div>
<div class="line">ecs::Entity e = w.add();</div>
<div class="line">w.add&lt;Position&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add and remove multiple components. </span></div>
<div class="line"><span class="comment">// This does one archetype movement rather than 6 compared to doing these operations separate.</span></div>
<div class="line">w.build(e)</div>
<div class="line"> <span class="comment">// add Velocity to entity e</span></div>
<div class="line"> .add&lt;Velocity&gt;()</div>
<div class="line"> <span class="comment">// remove Position from entity e</span></div>
<div class="line"> .del&lt;Position&gt;()</div>
<div class="line"> <span class="comment">// add Rotation to entity e</span></div>
<div class="line"> .add&lt;Rotation&gt;()</div>
<div class="line"> <span class="comment">// set a name for the entity if desired</span></div>
<div class="line"> .name(<span class="stringliteral">&quot;MyEntity);</span></div>
</div><!-- fragment --><p>It is also possible to manually commit all changes by calling <em><b>ecs::EntityBuilder::commit</b></em>. This is useful in scenarios where you have some branching and do not want to duplicate your code for both branches or simply need to add/remove components based on some complex logic.</p>
<div class="fragment"><div class="line">ecs::EntityBuilder builder = w.build(e);</div>
<div class="line">builder</div>
<div class="line">  .add&lt;Velocity&gt;()</div>
<div class="line">  .del&lt;Position&gt;();</div>
<div class="line"><span class="keywordflow">if</span> (some_condition) {</div>
<div class="line">  builder.add&lt;Rotation&gt;();</div>
<div class="line">}</div>
<div class="line">builder.commit();</div>
</div><!-- fragment --><p>&gt;<b>NOTE:</b><br  />
Once <em><b>ecs::EntityBuilder::commit</b></em> is called (either manually or internally when the builder's destructor is invoked) the contents of builder are returned to its default state.</p>
<h3><a class="anchor" id="set-or-get-component-value"></a>
Set or get component value</h3>
<div class="fragment"><div class="line"><span class="comment">// Change Velocity&#39;s value.</span></div>
<div class="line">w.set&lt;Velocity&gt;(e) = {0, 0, 2};</div>
<div class="line"><span class="comment">// Same as above but the world version is not updated so nobody gets notified of this change.</span></div>
<div class="line">w.sset&lt;Velocity&gt;(e) = {4, 2, 0};</div>
</div><!-- fragment --><p>When setting multiple component values at once it is more efficient doing it via chaining:</p>
<div class="fragment"><div class="line">w.acc_mut(e)</div>
<div class="line"><span class="comment">// Change Velocity&#39;s value on entity &quot;e&quot;</span></div>
<div class="line">  .set&lt;Velocity&gt;({0, 0, 2})</div>
<div class="line"><span class="comment">// Change Position&#39;s value on entity &quot;e&quot;</span></div>
<div class="line">  .set&lt;Position&gt;({0, 100, 0})</div>
<div class="line"><span class="comment">// Change...</span></div>
<div class="line">  .set...;</div>
</div><!-- fragment --><p>Similar to <em><b>ecs::EntityBuilder::build</b></em> you can also use the setter object in scenarios with complex logic.</p>
<div class="fragment"><div class="line">ecs::ComponentSetter setter = w.acc_mut(e);</div>
<div class="line">setter.set&lt;Velocity&gt;({0, 0, 2});</div>
<div class="line"><span class="keywordflow">if</span> (some_condition)</div>
<div class="line">  setter.set&lt;Position&gt;({0, 100, 0});</div>
<div class="line">setter.set&lt;Something&gt;({ ... }).set&lt;Else&gt;({ ... });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// You can also retrieve a reference to data (for AoS) or the data accessor (for SoA)</span></div>
<div class="line"><span class="keyword">auto</span>&amp; vel = setter.mut&lt;Velocity&gt;();</div>
<div class="line"><span class="keyword">auto</span>&amp; pos = setter.mut&lt;Position&gt;();</div>
</div><!-- fragment --><p>Components up to 8 bytes (including) are returned by value. Bigger components are returned by const reference.</p>
<div class="fragment"><div class="line"><span class="comment">// Read Velocity&#39;s value. As shown above Velocity is 12 bytes in size.</span></div>
<div class="line"><span class="comment">// Therefore, it is returned by const reference.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; velRef = w.get&lt;Velocity&gt;(e);</div>
<div class="line"><span class="comment">// However, it is easy to store a copy.</span></div>
<div class="line"><span class="keyword">auto</span> velCopy = w.get&lt;Velocity&gt;(e);</div>
</div><!-- fragment --><p>Both read and write operations are also accessible via views. Check the <a class="el" href="index.html#iteration">iteration</a> sections to see how.</p>
<h3><a class="anchor" id="copy-entity"></a>
Copy entity</h3>
<p>A copy of another entity can be easily created.</p>
<div class="fragment"><div class="line"><span class="comment">// Create an entity with Position and Velocity.</span></div>
<div class="line">ecs::Entity e = w.add();</div>
<div class="line">w.add(e, position, Position{0, 100, 0});</div>
<div class="line">w.add(e, velocity, Velocity{0, 0, 1});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Make a copy of &quot;e&quot;. Component values on the copied entity will match the source.</span></div>
<div class="line"><span class="comment">// Value of Position on &quot;e2&quot; will be {0, 100, 0}.</span></div>
<div class="line"><span class="comment">// Value of Velocity on &quot;e2&quot; will be {0, 0, 1}.</span></div>
<div class="line">ecs::Entity e2 = w.copy(e);</div>
</div><!-- fragment --> <h3><a class="anchor" id="entity-cleanup"></a>
Entity cleanup</h3>
<p>Anything attached to an entity can be easily removed using <em><b>World::clear</b></em>. This is useful when you need to quickly reset your entity and still want to keep your Entity's id (deleting the entity would mean that as some point it could be recycled and its id could be used by some newly created entity).</p>
<div class="fragment"><div class="line">ecs::Entity e = w.add();</div>
<div class="line">ecs::Entity something = w.add();</div>
<div class="line"><span class="comment">// Add a Position component to our entity</span></div>
<div class="line">w.add&lt;Position&gt;(e, {0, 100, 0});</div>
<div class="line"><span class="comment">// Add the &quot;something&quot; entity to our entity</span></div>
<div class="line">w.add(e, something);</div>
<div class="line"><span class="comment">// Remove anything attached to out entity</span></div>
<div class="line">w.clear(e);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> hasPosition = w.has&lt;Position&gt;(e); <span class="comment">// false</span></div>
<div class="line"><span class="keywordtype">bool</span> hasSomething = w.has(e, something); <span class="comment">// false</span></div>
</div><!-- fragment --><h3><a class="anchor" id="batched-creation"></a>
Batched creation</h3>
<p>Another way to create entities is by creating many of them at once. This is more performant than creating entities one by one.</p>
<div class="fragment"><div class="line"><span class="comment">// Create 1000 empty entities</span></div>
<div class="line">w.add(1000);</div>
<div class="line">w.add(1000, [](Entity newEntity) {</div>
<div class="line">  <span class="comment">// Do something with the new entity</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create an entity with Position and Velocity.</span></div>
<div class="line">ecs::Entity e = w.add();</div>
<div class="line">w.add(e, position, Position{0, 100, 0});</div>
<div class="line">w.add(e, velocity, Velocity{0, 0, 1});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create 1000 more entities like &quot;e&quot;.</span></div>
<div class="line"><span class="comment">// Their component values are not initialized to any particular value.</span></div>
<div class="line">w.add_n(e, 1000);</div>
<div class="line">w.add_n(e, 1000, [](Entity newEntity) {</div>
<div class="line">  <span class="comment">// Do something with the new entity</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create 1000 more entities like &quot;e&quot;.</span></div>
<div class="line"><span class="comment">// Their component values are going to be the same as &quot;e&quot;.</span></div>
<div class="line">w.copy_n(e, 1000);</div>
<div class="line">w.copy_n(e, 1000, [](Entity newEntity) {</div>
<div class="line">  <span class="comment">// Do something with the new entity</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">});</div>
<div class="line">w.copy_n(e, 1000, [](ecs::CopyIter&amp; it) {</div>
<div class="line">  <span class="keyword">auto</span> entityView = it.view&lt;ecs::Entity&gt;();</div>
<div class="line">  <span class="comment">// You can also access the view of components attached to the entity</span></div>
<div class="line">  <span class="keyword">auto</span> someView = it.view&lt;SomeComponent&gt;();</div>
<div class="line">  GAIA_EACH(it) {</div>
<div class="line">    <span class="comment">// Do something with the new entities</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --> <h3><a class="anchor" id="entity-lifespan"></a>
Entity lifespan</h3>
<p>Every entity in the world is reference counted. When an entity is created, the value of this counter is 1. When <em><b>ecs::World::del</b></em> is called the value of this counter is decremented. When it reaches zero, the entity is deleted. However, the lifetime of entities can be extended. Calling <em><b>ecs::World::del</b></em> any number of times on the same entity is safe because the reference counter is decremented only on the first attempt. Any further attempts are ignored.</p>
<h4><a class="anchor" id="safeentity"></a>
SafeEntity</h4>
<p><em><b>ecs::SafeEntity</b></em> is a wrapper above <em><b>ecs::Entity</b></em> that makes sure that an entity stays alive until the last <em><b>ecs::SafeEntity</b></em> referencing the entity goes out of scope. When the wrapper is instantiated it increments the entity's reference counter by 1. When it goes out of scope it decrements the counter by 1. In terms of functionality, this is reminiscent of a C++ smart pointer, std::shared_ptr.</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line"><span class="comment">// Create an entity. Its reference counter is 1.</span></div>
<div class="line">ecs::Entity player = w.add();</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Make sure the entity survives so long playerSafe exists. Reference counter is incremented to 2.</span></div>
<div class="line">  <span class="keyword">auto</span> playerSafe = ecs::SafeEntity(w, player);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Try to delete the player entity. The reference counter is decremented to 1.</span></div>
<div class="line">  <span class="comment">// It is not zero and therefore the entity player is not deleted.</span></div>
<div class="line">  w.del(player);</div>
<div class="line">  <span class="keywordtype">bool</span> isValid = w.valid(player); <span class="comment">// true</span></div>
<div class="line">  <span class="comment">// We can try deleting the entity again but the request is ignored this time.</span></div>
<div class="line">  <span class="comment">// Calling del on an entity decrements the reference counter only once. Further</span></div>
<div class="line">  <span class="comment">// calls are dropped. Hence, the reference counter remains 1.</span></div>
<div class="line">  w.del(player);</div>
<div class="line">  isValid = w.valid(player); <span class="comment">// true</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Here, playerSafe is out of scope. Reference counter is decremented to 0.</span></div>
<div class="line"><span class="comment">// Internally, w.del(player) is called.</span></div>
<div class="line"><span class="comment">// ... it&#39;s not safe to use player at this point anymore.</span></div>
<div class="line"><span class="keywordtype">bool</span> isValid = w.valid(player); <span class="comment">// false</span></div>
</div><!-- fragment --><p>ecs::SafeEntity is fully compatible with ecs::Entity and can be used just like it in all scenarios.</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line">ecs::Entity player = w.add();</div>
<div class="line"><span class="keyword">auto</span> playerSafe = ecs::SafeEntity(w, player);</div>
<div class="line"><span class="comment">// Add a Position component to playerSafe (player)</span></div>
<div class="line">w.add&lt;Position&gt;(playerSafe);</div>
<div class="line"><span class="comment">// w.add&lt;Position&gt;(player) &lt;-- this would do the same thing</span></div>
</div><!-- fragment --><h4><a class="anchor" id="weakentity"></a>
WeakEntity</h4>
<p><em><b>ecs::WeakEntity</b></em> is a wrapper above <em><b>ecs::Entity</b></em> that makes sure that when the entity it references is deleted, it automatically starts acting as <em><b>ecs::EntityBad</b></em>. In terms of functionality, this is reminiscent of a C++ smart pointer, std::weak_ptr.</p>
<p><em><b>ecs::WeakEntity</b></em> is fully compatible with <em><b>ecs::Entity</b></em> and can be used just like it in all scenarios. As a result, you have to keep in mind that it can become invalid at any point.</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line"><span class="comment">// Create an entity. Its reference counter is 1.</span></div>
<div class="line">ecs::Entity player = w.add();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a &quot;weak reference&quot; to the entity player</span></div>
<div class="line"><span class="keyword">auto</span> playerSafe = ecs::WeakEntity(w, player);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add a Position component to playerSafe (player)</span></div>
<div class="line">w.add&lt;Position&gt;(playerSafe);</div>
<div class="line"><span class="comment">// w.add&lt;Position&gt;(player) &lt;-- this would do the same thing</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Calling del decrements the reference count of entity by 1. In this case, the reference counter</span></div>
<div class="line"><span class="comment">// becomes 0 and therefore the entity is deleted.</span></div>
<div class="line"><span class="comment">// Our playerSafe automatically becomes EntityBad.</span></div>
<div class="line">w.del(player);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> isValid;</div>
<div class="line">isValid = w.valid(player); <span class="comment">// false</span></div>
<div class="line">isValid = w.valid(playerSafe); <span class="comment">// false</span></div>
</div><!-- fragment --><p>Technically, <em><b>ecs::WeakEntity</b></em> is almost the same thing as <em><b>ecs::Entity</b></em> with one nuance difference. Because entity ids are recycled, in theory, <em><b>ecs::Entity</b></em> left lying around somewhere could end up being multiple different things over time. This is not an issue with <em><b>ecs::WeakEntity</b></em> because the moment the entity linked with it gets deleted, it is reset to <em><b>ecs::EntityBad</b></em>.</p>
<p>This is an edge-case scenario, unlikely to happen even, but should you ever need it <em><b>ecs::WeakEntity</b></em> is there to help. If you decided to change the amount of bits allocated to <em><b>Entity::gen</b></em> to a lower number you will increase the likelihood of double-recycling happening and increase usefulness of <em><b>ecs::WeakEntity</b></em>.</p>
<p>A more useful use case, however, would be if you need an entity identifier that gets automatically reset when the entity gets deleted without any setup necessary from your end. Certain situations can be complex and using <em><b>ecs::WeakEntity</b></em> just might be the one way for you to address them.</p>
<h3><a class="anchor" id="archetype-lifespan"></a>
Archetype lifespan</h3>
<p>Once all entities of given archetype are deleted (and as a result all chunks in the archetypes are empty), the archetype stays alive for another 127 ticks of <em><b>ecs::World::update</b></em>. However, there might be cases where this behavior is insufficient. Maybe you want the archetype deleted faster, or you want to keep it around forever.</p>
<p>For instance, you might often end up deleting all entities of a given archetype only to create new ones seconds later. In this case, keeping the archetype around can have several performance benefits: 1) no need to recreate the archetype 2) no need to rematch queries with the archetype</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line">ecs::Entity player0 = w.add(); <span class="comment">// player0 belongs to archetype A</span></div>
<div class="line">ecs::Entity teamA = w.add(); <span class="comment">// teamA belongs to archetype A</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Player0 becomes a part of archetype B.</span></div>
<div class="line">w.add(player0, teamA);</div>
<div class="line"><span class="comment">// Archetype B is never going to be deleted.</span></div>
<div class="line">w.set_max_lifespan(player0, 0);</div>
<div class="line"><span class="comment">// Archetype B is going to be deleted after 20 ticks of ecs::World::update.</span></div>
<div class="line">w.set_max_lifespan(player0, 20);</div>
<div class="line"><span class="comment">// Reset maximum lifespan of the archetype B belongs to.</span></div>
<div class="line">w.set_max_lifespan(player0);</div>
</div><!-- fragment --><p>Note, if the entity that changed an archetypes lifespan moves to a new archetype, the new archetypes lifespan will not be updated.</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line">ecs::Entity player0 = w.add(); <span class="comment">// player0 belongs to archetype A</span></div>
<div class="line">ecs::Entity teamA = w.add(); <span class="comment">// teamA belongs to archetype A</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Player0 becomes a part of archetype B.</span></div>
<div class="line">w.add(player0, teamA);</div>
<div class="line"><span class="comment">// Maximum lifespan of archetype B changed to 20.</span></div>
<div class="line">w.set_max_lifespan(player0, 20);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Player0 becomes a part of archetype A again. Lifespan of B is still 20, lifespan of A is default.</span></div>
<div class="line">w.del(player0, team1); </div>
</div><!-- fragment --><p>In case you want to affect an archetype directly without abstracting it away you can retrieve it via the entity's container returned by World::fetch() function: </p><div class="fragment"><div class="line">EntityContainer&amp; ec = w.fetch(player0);</div>
<div class="line"><span class="comment">// Maximum lifespan of archetype the player0 entity belongs to changed to 50.</span></div>
<div class="line">ec.pArchetype-&gt;set_max_lifespan(50);</div>
</div><!-- fragment --><h2><a class="anchor" id="data-processing"></a>
Data processing</h2>
<h3><a class="anchor" id="query"></a>
Query</h3>
<p>For querying data you can use a Query. It can help you find all entities, components, or chunks matching a list of conditions and constraints and iterate them or return them as an array. You can also use them to quickly check if any entities satisfying your requirements exist or calculate how many of them there are.</p>
<p>Every Query is cached internally. You likely use the same query multiple times in your program, often without noticing. Because of that, caching becomes useful as it avoids wasting memory and performance when finding matches.</p>
<p>Note, the first Query invocation is always slower than the subsequent ones because internals of the Query need to be initialized.</p>
<div class="fragment"><div class="line">ecs::Query q = w.query();</div>
<div class="line">q.all&lt;Position&gt;(); <span class="comment">// Consider only entities with Position</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fill the entities array with entities with a Position component.</span></div>
<div class="line">cnt::darray&lt;ecs::Entity&gt; entities;</div>
<div class="line">q.arr(entities);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fill the positions array with position data.</span></div>
<div class="line">cnt::darray&lt;Position&gt; positions;</div>
<div class="line">q.arr(positions);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Calculate the number of entities satisfying the query</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> numberOfMatches = q.count();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check if any entities satisfy the query.</span></div>
<div class="line"><span class="comment">// Possibly faster than count() because it stops on the first match.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> hasMatches = !q.empty();</div>
</div><!-- fragment --><p>More complex queries can be created by combining All, Any, and None in any way you can imagine:</p>
<div class="fragment"><div class="line">ecs::Query q = w.query();</div>
<div class="line"><span class="comment">// Take into account everything with Position and Velocity (mutable access for both)...</span></div>
<div class="line">q.all&lt;Position&amp;&gt;();</div>
<div class="line">q.all&lt;Velocity&amp;&gt;();</div>
<div class="line"><span class="comment">// ... at least Something or SomethingElse (immutable access for both)...</span></div>
<div class="line">q.any&lt;Something&gt;().any&lt;SomethingElse&gt;();</div>
<div class="line"><span class="comment">// ... and no Player component... (no access done for no())</span></div>
<div class="line">q.not&lt;Player&gt;();</div>
</div><!-- fragment --><p>All Query operations can be chained and it is also possible to invoke various filters multiple times with unique components:</p>
<div class="fragment"><div class="line">ecs::Query q = w.query();</div>
<div class="line">  <span class="comment">// Take into account everything with Position (mutable access)...</span></div>
<div class="line">  .all&lt;Position&amp;&gt;()</div>
<div class="line">  <span class="comment">// ... and at the same time everything with Velocity (mutable access)...</span></div>
<div class="line">  .all&lt;Velocity&amp;&gt;()</div>
<div class="line">  <span class="comment">// ... at least Something or SomethingElse (immutable access)...</span></div>
<div class="line">  .any&lt;Something&gt;()</div>
<div class="line">  .any&lt;SomethingElse&gt;()</div>
<div class="line">  <span class="comment">// ... and no Player component (no access)...</span></div>
<div class="line">  .no&lt;Player&gt;(); </div>
</div><!-- fragment --><p>When the library is built with GAIA_USE_VARIADIC_API enabled (off by default) it is possible to use an even more convenient shortcut at the cost of possibly longer compilation time. This affects not only queries but some other features such as <a class="el" href="index.html#bulk-editing">EntityBuilder</a> or <a class="el" href="index.html#systems">systems</a> as well.</p>
<div class="fragment"><div class="line">ecs::Query q = w.query();</div>
<div class="line">  <span class="comment">// Take into account everything with Position (mutable access)</span></div>
<div class="line">  <span class="comment">// and at the same time everything with Velocity (mutable access)...</span></div>
<div class="line">  .all&lt;Position&amp;, Velocity&amp;&gt;()</div>
<div class="line">  <span class="comment">// ... at least Something or SomethingElse (immutable access)...</span></div>
<div class="line">  .any&lt;Something, SomethingElse&gt;()</div>
<div class="line">  <span class="comment">// ... and no Player component (no access)...</span></div>
<div class="line">  .no&lt;Player&gt;(); </div>
</div><!-- fragment --><p>Queries can be defined using a low-level API (used internally).</p>
<div class="fragment"><div class="line">ecs::Entity p = w.add&lt;Position&gt;().entity;</div>
<div class="line">ecs::Entity v = w.add&lt;Velocity&gt;().entity;</div>
<div class="line">ecs::Entity s = w.add&lt;Something&gt;().entity;</div>
<div class="line">ecs::Entity se = w.add&lt;SomethingElse&gt;().entity;</div>
<div class="line">ecs::Entity pl = w.add&lt;Player&gt;().entity;</div>
<div class="line"> </div>
<div class="line">ecs::Query q = w.query();</div>
<div class="line">  <span class="comment">// Take into account everything with Position (mutable access)...</span></div>
<div class="line">  .add({p, QueryOpKind::All, QueryAccess::Write})</div>
<div class="line">  <span class="comment">// ... and at the same time everything with Velocity (mutable access)...</span></div>
<div class="line">  .add({v, QueryOpKind::All, QueryAccess::Write})</div>
<div class="line">  <span class="comment">// ... at least Something or SomethingElse (immutable access)..</span></div>
<div class="line">  .add({s, QueryOpKind::Any, QueryAccess::Read})</div>
<div class="line">  .add({se, QueryOpKind::Any, QueryAccess::Read})</div>
<div class="line">  <span class="comment">// ... and no Player component (no access)...</span></div>
<div class="line">  .add({pl, QueryOpKind::None, QueryAccess::None}); </div>
</div><!-- fragment --><p>Building cache requires memory. Because of that, sometimes it comes handy having the ability to release this data. Calling <code>myQuery.reset()</code> will remove any data allocated by the query. The next time the query is used to fetch results the cache is rebuilt.</p>
<div class="fragment"><div class="line">q.reset();</div>
</div><!-- fragment --><p>If this is a cached query, even after resetting it it still remains in the query cache. To remove it from there all queries with the matching signature will need to be destroyed first:</p>
<div class="fragment"><div class="line">ecs::Query q1 = w.query();</div>
<div class="line">ecs::Query q2 = w.query();</div>
<div class="line">q1.add&lt;Position&gt;();</div>
<div class="line">q2.add&lt;Position&gt;();</div>
<div class="line"> </div>
<div class="line">(void)q1.count(); <span class="comment">// do some operation that compiles the query and inserts it into the query cache</span></div>
<div class="line">(void)q2.count(); <span class="comment">// do some operation that compiles the query and inserts it into the query cache</span></div>
<div class="line"> </div>
<div class="line">q1 = w.query(); <span class="comment">// First reference to cached query is destroyed.</span></div>
<div class="line">q2 = w.query(); <span class="comment">// Last reference to cache query is destroyed. The cache is cleared of queries with the given signature</span></div>
</div><!-- fragment --><p>Technically, any query could be reset by default initializing it, e.g. <code>myQuery = {}</code>. This, however, puts the query into an invalid state. Only queries created via World::query have a valid state.</p>
<h3><a class="anchor" id="query-string"></a>
Query string</h3>
<p>Another way to define queries is using the string notation. This allows you to define the entire query or its parts using a string composed of simple expressions. Any spaces in between modifiers and expressions are trimmed.</p>
<p>Supported modifiers:</p><ul>
<li><em><b>;</b></em> - separates expressions</li>
<li><em><b>?</b></em> - query::any</li>
<li><em><b>!</b></em> - query::none</li>
<li><em><b>&amp;</b></em> - read-write access</li>
<li><em><b>e</b></em> - entity value</li>
<li><em><b>(rel,tgt)</b></em> - relationship pair, a wildcard character in either rel or tgt is translated into <em><b>All</b></em></li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Some context for the example</span></div>
<div class="line"><span class="keyword">struct </span>Position {...};</div>
<div class="line"><span class="keyword">struct </span>Velocity {...};</div>
<div class="line"><span class="keyword">struct </span>RigidBody {...};</div>
<div class="line"><span class="keyword">struct </span>Fuel {...};</div>
<div class="line">ecs::Entity player = w.add();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the query from a string expression.</span></div>
<div class="line">ecs::Query q = w.query()</div>
<div class="line">  .add(<span class="stringliteral">&quot;&amp;Position; !Velocity; ?RigidBody; (Fuel,*); %e&quot;</span>, player.value());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// It does not matter how we split the expressions. This query is the same as the above.</span></div>
<div class="line">ecs::Query q1 = w.query()</div>
<div class="line">  .add(<span class="stringliteral">&quot;&amp;Position; !Velocity;&quot;</span>)</div>
<div class="line">  .add(<span class="stringliteral">&quot;?RigidBody; (Fuel,*)&quot;</span>)</div>
<div class="line">  .add(<span class="stringliteral">&quot;%e&quot;</span>, player.value());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The queries above can be rewritten as following:</span></div>
<div class="line">ecs::Query q2 = w.query()</div>
<div class="line">  .all&lt;Position&amp;&gt;()</div>
<div class="line">  .no&lt;Velocity&gt;()</div>
<div class="line">  .any&lt;RigidBody&gt;()</div>
<div class="line">  .all(ecs::Pair(w.add&lt;Fuel&gt;().entity, All)&gt;()</div>
<div class="line">  .all(player);</div>
</div><!-- fragment --><h3><a class="anchor" id="uncached-query"></a>
Uncached query</h3>
<p>From the implementation standpoint, uncached queries are the same as ordinary queries in all but one aspect - they do not use the query cache internally. This means that two uncached queries using the same setup are going to evaluate matches separately. As a result, if there are duplicates, more memory, and performance will be wasted.</p>
<p>On the other hand, if you design your queries carefully and they are all different, uncached queries are actually a bit faster to create and match. Creation is faster because there is no hash to compute for the query and matching is faster because no query cache lookups are involved.</p>
<p>Uncached queries are created via <em><b>World::query&lt; false &gt;</b></em>.</p>
<div class="fragment"><div class="line"><span class="comment">// This is a cached query</span></div>
<div class="line">ecs::Query q1 = w.query&lt;<span class="keyword">true</span>&gt;(). ...; </div>
<div class="line"><span class="comment">// This is a cached query, shorter version of the above</span></div>
<div class="line">ecs::Query q2 = w.query(). ...;</div>
<div class="line"><span class="comment">// This is an uncached query</span></div>
<div class="line">ecs::QueryUncached q3 = w.query&lt;<span class="keyword">false</span>&gt;(). ...; </div>
</div><!-- fragment --><h3><a class="anchor" id="iteration"></a>
Iteration</h3>
<p>To process data from queries one uses the <em><b>Query::each</b></em> function. It accepts either a list of components or an iterator as its argument.</p>
<div class="fragment"><div class="line">ecs::Query q = w.query();</div>
<div class="line">  <span class="comment">// Take into account all entities with Position and Velocity...</span></div>
<div class="line">  .all&lt;Position&amp;&gt;();</div>
<div class="line">  .all&lt;Velocity&gt;();</div>
<div class="line">  <span class="comment">// ... but no Player component.</span></div>
<div class="line">  .no&lt;Player&gt;();</div>
<div class="line"> </div>
<div class="line">q.each([&amp;](Position&amp; p, <span class="keyword">const</span> Velocity&amp; v) {</div>
<div class="line">  <span class="comment">// Run the scope for each entity with Position, Velocity and no Player component</span></div>
<div class="line">  p.x += v.x * dt;</div>
<div class="line">  p.y += v.y * dt;</div>
<div class="line">  p.z += v.z * dt;</div>
<div class="line">});</div>
</div><!-- fragment --><p>&gt;<b>NOTE:</b><br  />
Iterating over components not present in the query is not supported and results in asserts and undefined behavior. This is done to prevent various logic errors which might sneak in otherwise.</p>
<p>Processing via an iterator gives you even more expressive power, and opens doors for new kinds of optimizations. <em><b>Iter</b></em> is an abstraction over underlying data structures and gives you access to their public API.</p>
<p>There are three types of iterators: 1) <em><b>Iter</b></em> - iterates over enabled entities 2) <em><b>IterDisabled</b></em> - iterates over disabled entities 3) <em><b>IterAll</b></em> - iterates over all entities</p>
<div class="fragment"><div class="line">ecs::Query q = w.query();</div>
<div class="line">  .all&lt;Position&amp;&gt;()</div>
<div class="line">  .all&lt;Velocity&gt;();</div>
<div class="line"> </div>
<div class="line">q.each([](ecs::IterAll&amp; it) {</div>
<div class="line">  <span class="keyword">auto</span> p = it.view_mut&lt;Position&gt;(); <span class="comment">// Read-write access to Position</span></div>
<div class="line">  <span class="keyword">auto</span> v = it.view&lt;Velocity&gt;(); <span class="comment">// Read-only access to Velocity</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Iterate over all enabled entities and update their x-axis position.</span></div>
<div class="line">  <span class="comment">// GAIA_EACH(it) translates to: for (uint32_t i=0; i&lt;it.size(); ++i)</span></div>
<div class="line">  GAIA_EACH(it) {</div>
<div class="line">    <span class="keywordflow">if</span> (!it.enabled(i))</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    p[i].x += 1.f;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Iterate over all entities and update their position based on their velocity.</span></div>
<div class="line">  GAIA_EACH(it) {</div>
<div class="line">    p[i].x += v[i].x * dt;</div>
<div class="line">    p[i].y += v[i].y * dt;</div>
<div class="line">    p[i].z += v[i].z * dt;</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><p>Performance of views can be improved slightly by explicitly providing the index of the component in the query.</p>
<div class="fragment"><div class="line">ecs::Query q = w.query();</div>
<div class="line">q.any&lt;Something&gt;()</div>
<div class="line"> .all&lt;Position&amp;&gt;()</div>
<div class="line"> .all&lt;Velocity&gt;();</div>
<div class="line"> </div>
<div class="line">q.each([](ecs::IterAll&amp; it) {</div>
<div class="line">  <span class="keyword">auto</span> s = it.view&lt;Something&gt;(0); <span class="comment">// Something is fhe first defined component in the query</span></div>
<div class="line">  <span class="keyword">auto</span> p = it.view_mut&lt;Position&gt;(1); <span class="comment">// Position is the second defined component in the query</span></div>
<div class="line">  <span class="keyword">auto</span> v = it.view&lt;Velocity&gt;(2); <span class="comment">// Velocity is the third defined component in the query</span></div>
<div class="line">  ....</div>
<div class="line">}</div>
</div><!-- fragment --><p>&gt;<b>NOTE:</b><br  />
The functor accepting an iterator can be called any number of times per one <em><b>Query::each</b></em>. Currently, the functor is invoked once per archetype chunk that matches the query. In the future, this can change. Therefore, it is best to make no assumptions about it and simply expect that the functor might be triggered multiple times per call to <em><b>each</b></em>.</p>
<h3><a class="anchor" id="constraints"></a>
Constraints</h3>
<p>Query behavior can also be modified by setting constraints. By default, only enabled entities are taken into account. However, by changing constraints, we can filter disabled entities exclusively or make the query consider both enabled and disabled entities at the same time.</p>
<p>Disabling or enabling an entity is a special operation that is invisible to queries. The entitys archetype is not changed, so the operation is fast.</p>
<div class="fragment"><div class="line">ecs::Entity e1, e2;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create 2 entities with Position component</span></div>
<div class="line">w.add(e1);</div>
<div class="line">w.add(e2);</div>
<div class="line">w.add&lt;Position&gt;(e1);</div>
<div class="line">w.add&lt;Position&gt;(e2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Disable the first entity</span></div>
<div class="line">w.enable(e1, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check if e1 is enabled</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> is_e1_enabled = w.enabled(e1);</div>
<div class="line"><span class="keywordflow">if</span> (is_e1_enabled) { ... }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare out query</span></div>
<div class="line">ecs::Query q = w.query().all&lt;Position&amp;&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fills the array with only e2 because e1 is disabled.</span></div>
<div class="line">cnt::darray&lt;ecs::Entity&gt; entities;</div>
<div class="line">q.arr(entities);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fills the array with both e1 and e2.</span></div>
<div class="line">q.arr(entities, ecs::Query::Constraint::AcceptAll);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fills the array with only e1 because e1 is disabled.</span></div>
<div class="line">q.arr(entities, ecs::Query::Constraint::DisabledOnly);</div>
<div class="line"> </div>
<div class="line">q.each([](ecs::Iter&amp; it) {</div>
<div class="line">  <span class="keyword">auto</span> p = it.view_mut&lt;Position&gt;(); <span class="comment">// Read-Write access to Position</span></div>
<div class="line">  <span class="comment">// Iterates over enabled entities</span></div>
<div class="line">  GAIA_EACH(it) p[i] = {}; <span class="comment">// reset the position of each enabled entity</span></div>
<div class="line">});</div>
<div class="line">q.each([](ecs::IterDisabled&amp; it) {</div>
<div class="line">  <span class="keyword">auto</span> p = it.view_mut&lt;Position&gt;(); <span class="comment">// Read-Write access to Position</span></div>
<div class="line">  <span class="comment">// Iterates over disabled entities</span></div>
<div class="line">  GAIA_EACH(it) p[i] = {}; <span class="comment">// reset the position of each disabled entity</span></div>
<div class="line">});</div>
<div class="line">q.each([](ecs::IterAll&amp; it) {</div>
<div class="line">  <span class="keyword">auto</span> p = it.view_mut&lt;Position&gt;(); <span class="comment">// Read-Write access to Position</span></div>
<div class="line">  <span class="comment">// Iterates over all entities</span></div>
<div class="line">  GAIA_EACH(it) {</div>
<div class="line">    <span class="keywordflow">if</span> (it.enabled(i)) {</div>
<div class="line">      p[i] = {}; <span class="comment">// reset the position of each enabled entity</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><p>If you do not wish to fragment entities inside the chunk you can simply create a tag component and assign it to your entity. This will move the entity to a new archetype so it is a lot slower. However, because disabled entities are now clearly separated calling some query operations might be slightly faster (no need to check if the entity is disabled or not internally).</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Disabled {};</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">e.add&lt;Disabled&gt;(); <span class="comment">// disable entity</span></div>
<div class="line"> </div>
<div class="line">ecs::Query q = w.query()</div>
<div class="line">  .all&lt;Position&gt;()</div>
<div class="line">  .all&lt;Disabled&gt;;</div>
<div class="line"> </div>
<div class="line">q.each([&amp;](ecs::Iter&amp; it){</div>
<div class="line">  <span class="comment">// Processes all disabled entities</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">e.del&lt;Disabled&gt;(); <span class="comment">// enable entity</span></div>
</div><!-- fragment --><h3><a class="anchor" id="change-detection"></a>
Change detection</h3>
<p>Using changed we can make the iteration run only if particular components change. You can save quite a bit of performance using this technique.</p>
<div class="fragment"><div class="line">ecs::Query q = w.query();</div>
<div class="line">  <span class="comment">// Take into account all entities with Position and Velocity...</span></div>
<div class="line">  .all&lt;Position&amp;&gt;()</div>
<div class="line">  .all&lt;Velocity&gt;();</div>
<div class="line">  <span class="comment">// ... no Player component...</span></div>
<div class="line">  .no&lt;Player&gt;(); </div>
<div class="line">  <span class="comment">// ... but only iterate when Velocity changes</span></div>
<div class="line">  .changed&lt;Velocity&gt;();</div>
<div class="line"> </div>
<div class="line">q.each([&amp;](Position&amp; p, <span class="keyword">const</span> Velocity&amp; v) {</div>
<div class="line">  <span class="comment">// This scope runs for each entity with Position, Velocity and no Player component</span></div>
<div class="line">  <span class="comment">// but only when Velocity has changed.</span></div>
<div class="line">  p.x += v.x * dt;</div>
<div class="line">  p.y += v.y * dt;</div>
<div class="line">  p.z += v.z * dt;</div>
<div class="line">});</div>
</div><!-- fragment --><p>&gt;<b>NOTE:</b><br  />
If there are 100 Position components in the chunk and only one of them changes, the other 99 are considered changed as well. This chunk-wide behavior might seem counter-intuitive but it is in fact a performance optimization. The reason why this works is because it is easier to reason about a group of entities than checking each of them separately.</p>
<p>Changes are triggered as a result of: 1) adding or removing an entity 2) using <b>World::set</b> (<b>World::sset</b> aka silent set doesn't notify of changes) 3) using Iter::view_mut (<b>Iter::sview_mut</b> aka silent mutation doesn't notify of changes) 3) automatically done for mutable components passed to query (see the example above)</p>
<h3><a class="anchor" id="grouping"></a>
Grouping</h3>
<p>Grouping is a feature that allows you to assign an id to each archetype and group them together or filter them based on this id. Archetypes are sorted by their groupId in ascending order. If descending order is needed, you can change your groupIds (e.g. instead of 100 you use ecs::GroupIdMax - 100).</p>
<p>Grouping is best used with <a class="el" href="index.html#relationships">relationships</a>. It can be triggered by calling <em><b>group_by</b></em> before the first call to <em><b>each</b></em> or other functions that build the query (<em><b>count</b></em>, <em><b>empty</b></em>, <em><b>arr</b></em>).</p>
<div class="fragment"><div class="line">ecs::Entity eats = wld.add();</div>
<div class="line">ecs::Entity carrot = wld.add();</div>
<div class="line">ecs::Entity salad = wld.add();</div>
<div class="line">ecs::Entity apple = wld.add();</div>
<div class="line"> </div>
<div class="line">ecs::Entity ents[6];</div>
<div class="line">GAIA_FOR(6) ents[i] = wld.add();</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Add Position and ecs::Pair(eats, salad) to our entity</span></div>
<div class="line">  wld.build(ents[0]).add&lt;Position&gt;().add({eats, salad});</div>
<div class="line">  wld.build(ents[1]).add&lt;Position&gt;().add({eats, carrot});</div>
<div class="line">  wld.build(ents[2]).add&lt;Position&gt;().add({eats, apple});</div>
<div class="line"> </div>
<div class="line">  wld.build(ents[3]).add&lt;Position&gt;().add({eats, apple}).add&lt;Healthy&gt;();</div>
<div class="line">  wld.build(ents[4]).add&lt;Position&gt;().add({eats, salad}).add&lt;Healthy&gt;();</div>
<div class="line">  wld.build(ents[5]).add&lt;Position&gt;().add({eats, carrot}).add&lt;Healthy&gt;();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This query is going to group entities by what they eat.</span></div>
<div class="line">ecs::Query q = wld.query()</div>
<div class="line">  .all&lt;Position&gt;()</div>
<div class="line">  .group_by(eats);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The query cache is going to contain following 6 archetypes in 3 groups as follows:</span></div>
<div class="line"><span class="comment">//  - Eats:carrot:</span></div>
<div class="line"><span class="comment">//     - Position, (Eats, carrot)</span></div>
<div class="line"><span class="comment">//     - Position, (Eats, carrot), Healthy</span></div>
<div class="line"><span class="comment">//  - Eats:salad:</span></div>
<div class="line"><span class="comment">//     - Position, (Eats, salad)</span></div>
<div class="line"><span class="comment">//     - Position, (Eats, salad), Healthy</span></div>
<div class="line"><span class="comment">//  - Eats::apple:</span></div>
<div class="line"><span class="comment">//     - Position, (Eats, apple)</span></div>
<div class="line"><span class="comment">//     - Position, (Eats, apple), Healthy</span></div>
<div class="line">q.each([&amp;](ecs::Iter&amp; it) {</div>
<div class="line">  <span class="keyword">auto</span> ents = it.view&lt;ecs::Entity&gt;();</div>
<div class="line">  GAIA_EACH(it) {</div>
<div class="line">    GAIA_LOG_N(<span class="stringliteral">&quot;GrpId:%u, Entity:%u.%u&quot;</span>, it.group_id(), ents[i].id(), ents[i].gen());</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><p>You can choose what group to iterate specifically by calling ***group_id***prior to iteration.</p>
<div class="fragment"><div class="line"><span class="comment">// This query is going to iterate the following group of 2 archetypes:</span></div>
<div class="line"><span class="comment">//  - Eats:salad:</span></div>
<div class="line"><span class="comment">//     - Position, (Eats, salad)</span></div>
<div class="line"><span class="comment">//     - Position, (Eats, salad), Healthy</span></div>
<div class="line">q.group_id(salad).each([&amp;](ecs::Iter&amp; it) {</div>
<div class="line">  ...</div>
<div class="line">});</div>
<div class="line"><span class="comment">// This query is going to iterate the following group of 2 archetypes:</span></div>
<div class="line"><span class="comment">//  - Eats:carrot:</span></div>
<div class="line"><span class="comment">//     - Position, (Eats, carrot)</span></div>
<div class="line"><span class="comment">//     - Position, (Eats, carrot), Healthy</span></div>
<div class="line">q.group_id(carrot).each([&amp;](ecs::Iter&amp; it) {</div>
<div class="line">  ...</div>
<div class="line">});</div>
</div><!-- fragment --><p>Custom sorting function can be provided if needed.</p>
<div class="fragment"><div class="line">ecs::GroupId my_group_sort_func([[maybe_unused]] <span class="keyword">const</span> ecs::World&amp; world, <span class="keyword">const</span> ecs::Archetype&amp; archetype, ecs::Entity groupBy) {</div>
<div class="line">  <span class="keywordflow">if</span> (archetype.pairs() &gt; 0) {</div>
<div class="line">    <span class="keyword">auto</span> ids = archetype.ids_view();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keywordtype">id</span>: ids) {</div>
<div class="line">      <span class="keywordflow">if</span> (!<span class="keywordtype">id</span>.pair() || <span class="keywordtype">id</span>.<span class="keywordtype">id</span>() != groupBy.id())</div>
<div class="line">        <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Consider the pair&#39;s target the groupId</span></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keywordtype">id</span>.gen();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// No group</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">q.group_by(eats, my_group_sort_func).each(...) { ... };</div>
</div><!-- fragment --><h3><a class="anchor" id="sorting"></a>
Sorting</h3>
<p>Data stored in ECS can be sorted. We can sort either by entity index or by component of choice. To accomplish that the <em><b>Query::sort_by</b></em> function is used.</p>
<p>Sorting by entity indices in an descending order (largest entity indices first) could be done as follows:</p>
<div class="fragment"><div class="line">ecs::World wld;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create some entities</span></div>
<div class="line">ecs::Entity e0 = wld.add();</div>
<div class="line">ecs::Entity e1 = wld.add();</div>
<div class="line">ecs::Entity e2 = wld.add();</div>
<div class="line">ecs::Entity e3 = wld.add();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add a component to them</span></div>
<div class="line"><span class="keyword">struct </span>Something {</div>
<div class="line">  <span class="keywordtype">int</span> value;</div>
<div class="line">};</div>
<div class="line">wld.add&lt;Something&gt;(e0, {2});</div>
<div class="line">wld.add&lt;Something&gt;(e1, {4});</div>
<div class="line">wld.add&lt;Something&gt;(e2, {1});</div>
<div class="line">wld.add&lt;Something&gt;(e3, {3});</div>
<div class="line"> </div>
<div class="line">ecs::Query q = wld.query()</div>
<div class="line">  .all&lt;Something&gt;()</div>
<div class="line">  .sort_by(</div>
<div class="line">    <span class="comment">// Entity we sort by. We use ecs::EntityBad to sort by entity</span></div>
<div class="line">    ecs::EntityBad,</div>
<div class="line">    <span class="comment">// Sorting function</span></div>
<div class="line">    []([[maybe_unused]] <span class="keyword">const</span> ecs::World&amp; world, <span class="keyword">const</span> <span class="keywordtype">void</span>* pData0, <span class="keyword">const</span> <span class="keywordtype">void</span>* pData1) {</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; entity0 = *(<span class="keyword">const</span> ecs::Entity*)pData0;</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; entity1 = *(<span class="keyword">const</span> ecs::Entity*)pData1;</div>
<div class="line">      <span class="comment">// Sort by entity ID largest to smallest</span></div>
<div class="line">      <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)entity1.id() - (int)entity0.id()</div>
<div class="line">    });</div>
<div class="line">q.each([](Iter&amp; it) {</div>
<div class="line">  <span class="comment">// Entities are going to ordered as:</span></div>
<div class="line">  <span class="comment">// e3, e2, e1, e0</span></div>
<div class="line">});</div>
</div><!-- fragment --><p>It is also possible to sort by component data.</p>
<div class="fragment"><div class="line">ecs::Query q = wld.query()</div>
<div class="line">  .all&lt;Something&gt;()</div>
<div class="line">  .sort_by(</div>
<div class="line">    <span class="comment">// Sort by Something</span></div>
<div class="line">    wld.get&lt;Something&gt;(),</div>
<div class="line">    <span class="comment">// Sorting function</span></div>
<div class="line">    []([[maybe_unused]] <span class="keyword">const</span> ecs::World&amp; world, <span class="keyword">const</span> <span class="keywordtype">void</span>* pData0, <span class="keyword">const</span> <span class="keywordtype">void</span>* pData1) {</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; s0 = *(<span class="keyword">const</span> Something*)pData0;</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; s1 = *(<span class="keyword">const</span> Something*)pData1;</div>
<div class="line">      <span class="comment">// Sort by values, smallest to largest</span></div>
<div class="line">      <span class="keywordflow">return</span> s0.value - s1.value;</div>
<div class="line">    });</div>
<div class="line">q.each([](Iter&amp; it) {</div>
<div class="line">  <span class="comment">// Entities are going to ordered as:</span></div>
<div class="line">  <span class="comment">// e2, e0, e3, e1</span></div>
<div class="line">});</div>
</div><!-- fragment --><p>A templated version of the function is available for shorter code:</p>
<div class="fragment"><div class="line">ecs::Query q = wld.query()</div>
<div class="line">  .all&lt;Something&gt;()</div>
<div class="line">  .sort_by&lt;Something&gt;(</div>
<div class="line">    <span class="comment">// Sorting function</span></div>
<div class="line">    [](<span class="keyword">const</span> ecs::World&amp; world, <span class="keyword">const</span> <span class="keywordtype">void</span>* pData0, <span class="keyword">const</span> <span class="keywordtype">void</span>* pData1) {</div>
<div class="line">      ...</div>
<div class="line">    });</div>
<div class="line">q.each([](Iter&amp; it) { ... });</div>
</div><!-- fragment --><p>Sorting is an expensive operation and it is advised to use it only for data which is known to not change much. It is definitely not suited for actions happening all the time (unless the amount of entities to sort is small).</p>
<p>You can currently sort only by one criterion (you can pick only one entity/component inside an archetype). If you need more, it is recommended to store your data outside of ECS. Also, make sure multiple systems working with similar data don't end up sorting archetypes as this could trigger constant resorting.</p>
<p>During sorting, entities in chunks are reordered according to the sorting function. However, they are not sorted globally, only independently within chunks. To get a globally sorted view an acceleration structure is created. This way we can ensure data is moved as little as possible.</p>
<p>Resorting is triggered automatically any time the query matches a new archetype, or some of the archetypes it matched disappeared. Adding, deleting, or moving entities on the matched archetypes also triggers resorting.</p>
<h3><a class="anchor" id="parallel-execution"></a>
Parallel execution</h3>
<p>Queries can make use of <a class="el" href="index.html#multithreading">mulithreading</a>. By default, all queries are handles by the thread that iterates the query. However, it is possible to execute them by multiple threads at once simply by providing the right <em><b>ecs::QueryExecType</b></em> parameter.</p>
<div class="fragment"><div class="line"><span class="comment">// Ordinary single-thread query (default)</span></div>
<div class="line">q.each([](ecs::Iter&amp; iter) { ... });</div>
<div class="line"><span class="comment">// Ordinary single-thread query (explicit)</span></div>
<div class="line">q.each([](ecs::Iter&amp; iter) { ... }, ecs::QueryExecType::Default);</div>
<div class="line"><span class="comment">// Multi-thread query, use any cores available</span></div>
<div class="line">q.each([](ecs::Iter&amp; iter) { ... }, ecs::QueryExecType::Parallel);</div>
<div class="line"><span class="comment">// Multi-thread query, use performance cores only</span></div>
<div class="line">q.each([](ecs::Iter&amp; iter) { ... }, ecs::QueryExecType::ParallelPerf);</div>
<div class="line"><span class="comment">// Multi-thread query, use efficiency cores only</span></div>
<div class="line">q.each([](ecs::Iter&amp; iter) { ... }, ecs::QueryExecType::ParallelEff);</div>
</div><!-- fragment --><p>Not only is multi-threaded execution possible, but you can also influence what kind of cores actually run your logic. Maybe you want to limit your system's power consumption in which case you target only the efficiency cores. Or, if you want maximum performance, you can easily have all your system's cores participate.</p>
<p>Queries can't make use of job dependencies directly. To do that, you need to use <a class="el" href="index.html#system-jobs">systems</a>.</p>
<h2><a class="anchor" id="relationships"></a>
Relationships</h2>
<h3><a class="anchor" id="relationship-basics"></a>
Relationship basics</h3>
<p>Entity relationship is a feature that allows users to model simple relations, hierarchies or graphs in an ergonomic, easy and safe way. Each relationship is expressed as following: "source, (relation, target)". All three elements of a relationship are entities. We call the "(relation, target)" part a relationship pair.</p>
<p>Relationship pair is a special kind of entity where the id of the "relation" entity becomes the pair's id and the "target" entity's id becomes the pairs generation. The pair is created by calling <em><b>ecs::Pair(relation, target</b></em>) with two valid entities as its arguments.</p>
<p>Adding a relationship to any entity is as simple as adding any other entity.</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line">ecs::Entity rabbit = w.add();</div>
<div class="line">ecs::Entity hare = w.add();</div>
<div class="line">ecs::Entity carrot = w.add();</div>
<div class="line">ecs::Entity eats = w.add();</div>
<div class="line"> </div>
<div class="line">w.add(rabbit, ecs::Pair(eats, carrot));</div>
<div class="line">w.add(hare, ecs::Pair(eats, carrot));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// You can brace-initialize the pair as well which is shorter.</span></div>
<div class="line"><span class="comment">// w.add(hare, {eats, carrot});</span></div>
<div class="line"> </div>
<div class="line">ecs::Query q = w.query().all(ecs::Pair(eats, carrot));</div>
<div class="line">q.each([](ecs::Entity entity)) {</div>
<div class="line">  <span class="comment">// Called for each entity implementing (eats, carrot) relationship.</span></div>
<div class="line">  <span class="comment">// Triggers for rabbit and hare.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>This by itself would not be much different from adding entities/component to entities. A similar result can be achieved by creating a "eats_carrot" tag and assigning it to "hare" and "rabbit". What sets relationships apart is the ability to use wildcards in queries.</p>
<p>There are three kinds of wildcard queries possible:</p><ul>
<li><em><b>( X, * )</b></em> - X that does anything</li>
<li><em><b>( * , X )</b></em> - anything that does X</li>
<li><em><b>( * , * )</b></em> - anything that does anything (aka any relationship)</li>
</ul>
<p>The "*" wildcard is expressed via <em><b>All</b></em> entity.</p>
<div class="fragment"><div class="line">w.add(rabbit, ecs::Pair(eats, carrot));</div>
<div class="line">w.add(hare, ecs::Pair(eats, carrot));</div>
<div class="line">w.add(wolf, ecs::Pair(eats, rabbit));</div>
<div class="line"> </div>
<div class="line">ecs::Query q1 = w.query().all(ecs::Pair(eats, All));</div>
<div class="line">q1.each([]()) {</div>
<div class="line">  <span class="comment">// Called for each entity implementing (eats, *) relationship.</span></div>
<div class="line">  <span class="comment">// This can be read as &quot;entity that eats anything&quot;.</span></div>
<div class="line">  <span class="comment">// Triggers for rabbit, hare and wolf.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">ecs::Query q2 = w.query().all(ecs::Pair(All, carrot));</div>
<div class="line">q2.each([]()) {</div>
<div class="line">  <span class="comment">// Called for each entity implementing (*, carrot) relationship.</span></div>
<div class="line">  <span class="comment">// This can be read as &quot;anything that has something with carrot&quot;.</span></div>
<div class="line">  <span class="comment">// Triggers for rabbit and hare.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">ecs::Query q3 = w.query().all(ecs::Pair(All, All));</div>
<div class="line">q3.each([]()) {</div>
<div class="line">  <span class="comment">// Called for each entity implementing (*, *) relationship.</span></div>
<div class="line">  <span class="comment">// This can be read as &quot;anything that does/has anything&quot;.</span></div>
<div class="line">  <span class="comment">// Triggers for rabbit, hare and wolf.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Relationships can be ended by calling <em><b>World::del</b></em> (just like it is done for regular entities/components).</p>
<div class="fragment"><div class="line"><span class="comment">// Rabbit no longer eats carrot</span></div>
<div class="line">w.del(rabbit, ecs::Pair(eats, carrot));</div>
</div><!-- fragment --><p>Whether a relationship exists can be check via <em><b>World::has</b></em> (just like it is done for regular entities/components).</p>
<div class="fragment"><div class="line"><span class="comment">// Checks if rabbit eats carrot</span></div>
<div class="line">w.has(rabbit, ecs::Pair(eats, carrot));</div>
<div class="line"><span class="comment">// Checks if rabbit eats anything</span></div>
<div class="line">w.has(rabbit, ecs::Pair(eats, All));</div>
</div><!-- fragment --><p> A nice side-effect of relationships is they allow for multiple components/entities of the same kind be added to one entity.</p>
<div class="fragment"><div class="line"><span class="comment">// &quot;eats&quot; is added twice to the entity &quot;rabbit&quot;</span></div>
<div class="line">w.add(rabbit, ecs::Pair(eats, carrot));</div>
<div class="line">w.add(rabbit, ecs::Pair(eats, salad));</div>
</div><!-- fragment --><p>Pairs do not need to be formed from tag entities only. You can use components to build a pair which means they can store data, too! To determine the storage type of Pair(relation, target), the following logic is applied: 1) if "relation" is non-empty, the storage type is rel 2) if "relation" is empty and "target" is non-empty, the storage type is "target"</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Start{};</div>
<div class="line"><span class="keyword">struct </span>Position{ <span class="keywordtype">int</span> x, y; };</div>
<div class="line">...</div>
<div class="line">ecs::Entity e = w.add();</div>
<div class="line"><span class="comment">// Add (Start, Position) from component entities.</span></div>
<div class="line">ecs::Entity start_entity = w.add&lt;Start&gt;().entity;</div>
<div class="line">ecs::Entity pos_entity = w.add&lt;Position&gt;().entity;</div>
<div class="line">w.add(e, ecs::Pair(start_entity, pos_entity));</div>
<div class="line"><span class="comment">// Add (Start, Position) pair to entity e using a compile-time component pair.</span></div>
<div class="line">w.add&lt;ecs::pair&lt;Start, Position&gt;(e);</div>
<div class="line"><span class="comment">// Add (Start, Position) pair to entity e using a compile-time component pair</span></div>
<div class="line"><span class="comment">// and set its value. According the rules defined above, the storage type used</span></div>
<div class="line"><span class="comment">// for the pair is Position.</span></div>
<div class="line">w.add&lt;ecs::pair&lt;Start, Position&gt;(e, {10, 15});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a query matching all (Start, Position) pairs using component entities</span></div>
<div class="line">ecs::Query q0 = w.query().all( ecs::Pair(start_entity, pos_entity) );</div>
<div class="line"><span class="comment">// Create a query matching all (Start, Position) pairs using compile-time</span></div>
<div class="line">ecs::Query q1 = w.query().all&lt; ecs::pair&lt;Start, Position&gt; &gt;();</div>
</div><!-- fragment --><h3><a class="anchor" id="targets"></a>
Targets</h3>
<p>Targets of a relationship can be retrieved via <em><b>World::target</b></em> and <em><b>World::targets</b></em>.</p>
<div class="fragment"><div class="line">w.add(rabbit, ecs::Pair(eats, carrot));</div>
<div class="line">w.add(rabbit, ecs::Pair(eats, salad));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns whatever the first found target of the rabbit(eats, *) relationship is.</span></div>
<div class="line"><span class="comment">// In our case it is the carrot entity because it was created before salad.</span></div>
<div class="line">ecs::Entity first_target = w.target(rabbit, eats);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Appends carrot and salad entities to the array</span></div>
<div class="line">cnt::sarr_ext&lt;ecs::Entity, 32&gt; what_rabbit_eats;</div>
<div class="line">w.targets(rabbit, eats, [&amp;what_rabbit_eats](ecs::Entity entity) {</div>
<div class="line">  what_rabbit_eats.push_back(entity);</div>
<div class="line">});</div>
</div><!-- fragment --><h3><a class="anchor" id="relations"></a>
Relations</h3>
<p>Relations of a relationship can be retrieved via <em><b>World::relation</b></em> and <em><b>World::relations</b></em>.</p>
<div class="fragment"><div class="line">w.add(rabbit, ecs::Pair(eats, carrot));</div>
<div class="line">w.add(rabbit, ecs::Pair(eats, salad));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns whatever the first found relation of the rabbit(*, salad) relationship is.</span></div>
<div class="line"><span class="comment">// In our case it is eats.</span></div>
<div class="line">ecs::Entity first_relation = w.relation(rabbit, salad);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Appends eats to the array</span></div>
<div class="line">cnt::sarr_ext&lt;ecs::Entity, 32&gt; related_to_salad;</div>
<div class="line">w.relations(rabbit, salad, [&amp;related_to_salad](ecs::Entity entity) {</div>
<div class="line">  related_to_salad.push_back(entity);</div>
<div class="line">});</div>
</div><!-- fragment --><h3><a class="anchor" id="entity-dependencies"></a>
Entity dependencies</h3>
<p>Defining dependencies among entities is made possible via the (Requires, target) relationship.</p>
<p>When adding an entity with a dependency to some source it is guaranteed the dependency will always be present on the source as well. It will also be impossible to delete it.</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line">ecs::Entity rabbit = w.add();</div>
<div class="line">ecs::Entity animal = w.add();</div>
<div class="line">ecs::Entity herbivore = w.add();</div>
<div class="line">ecs::Entity carrot = w.add();</div>
<div class="line">w.add(carrot, ecs::Pair(ecs::Requires, herbivore));</div>
<div class="line">w.add(herbivore, ecs::Pair(ecs::Requires, animal));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Carrot depends on herbivore so the later is added as well.</span></div>
<div class="line"><span class="comment">// At the same time, herbivore depends on animal so animal is added, too.</span></div>
<div class="line">w.add(rabbit, carrot);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> isHerbivore = w.has(rabbit, herbivore)); <span class="comment">// true</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> isAnimal = w.has(rabbit, animal); <span class="comment">// true</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Animal will not be removed from rabbit because of the dependency chain.</span></div>
<div class="line"><span class="comment">// Carrot depends on herbivore which depends on animal.</span></div>
<div class="line">w.del(rabbit, animal); <span class="comment">// does nothing</span></div>
<div class="line"><span class="comment">// Herbivore will not be removed from rabbit because of the dependency chain.</span></div>
<div class="line"><span class="comment">// Carrot depends on herbivore.</span></div>
<div class="line">w.del(rabbit, herbivore); <span class="comment">// does nothing</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Carrot can be deleted. It requires that herbivore is present which is true.</span></div>
<div class="line">w.del(rabbit, carrot); <span class="comment">// removes carrot from rabbit</span></div>
</div><!-- fragment --><h3><a class="anchor" id="combination-constraints"></a>
Combination constraints</h3>
<p>Entity constrains are used to define what entities can not be combined with others.</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line">ecs::Entity weak = w.add();</div>
<div class="line">ecs::Entity strong = w.add();</div>
<div class="line">w.add(weak, ecs::Pair(ecs::CantCombine, strong));</div>
<div class="line"> </div>
<div class="line">ecs::Entity e = w.add();</div>
<div class="line">w.add(e, strong);</div>
<div class="line"><span class="comment">// Following line is an invalid operation.</span></div>
<div class="line">w.add(e, weak);</div>
</div><!-- fragment --><h3><a class="anchor" id="exclusivity"></a>
Exclusivity</h3>
<p>Entities can be defined as exclusive. This means that only one relationship with this entity as a relation can exist. Any attempts to create a relationship with a different target replaces the previous relationship.</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line"><span class="comment">// Helper entities defining the state of a wall switch</span></div>
<div class="line">ecs::Entity on = w.add();</div>
<div class="line">ecs::Entity off = w.add();</div>
<div class="line"><span class="comment">// Create the &quot;toggled&quot; entity and define it as exclusive</span></div>
<div class="line">ecs::Entity toggled = w.add();</div>
<div class="line">w.add(toggled, ecs::Exclusive);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a wall switch entity. There can be only one relationship with {toggled, *} now.</span></div>
<div class="line"><span class="comment">// Therefore, adding {toggled, off} overrides the previous {toggled, on}.</span></div>
<div class="line">ecs::Entity wallSwitch = w.add();</div>
<div class="line">w.add(wallSwitch, ecs::Pair(toggled, on));</div>
<div class="line"><span class="keywordtype">bool</span> isSwitched = w.has(wallSwitch, ecs::Pair{toggled, on}); <span class="comment">// true</span></div>
<div class="line">w.add(wallSwitch, ecs::Pair(toggled, off));</div>
<div class="line">isSwitched = w.has(wallSwitch, ecs::Pair{toggled, on}); <span class="comment">// false</span></div>
</div><!-- fragment --><h3><a class="anchor" id="entity-inheritance"></a>
Entity inheritance</h3>
<p>Entities can inherit from other entities by using the (Is, target) relationship. This is a powerful feature that helps you identify an entire group of entities using a single entity.</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line">ecs::Entity animal = w.add();</div>
<div class="line">ecs::Entity rabbit = w.add();</div>
<div class="line">ecs::Entity wall = w.add();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Make rabbit an animal.</span></div>
<div class="line"><span class="comment">// This is an equivalent of:</span></div>
<div class="line"><span class="comment">// 1) w.add(animal, animal) &lt;-- makes sure animal has a separate archetype which can be matched</span></div>
<div class="line"><span class="comment">// 2) w.add(rabbit, ecs::Pair(ecs::Is, animal)) &lt;-- forms the relationship</span></div>
<div class="line">w.as(rabbit, animal);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check if an entity is inheriting from something</span></div>
<div class="line"><span class="keywordtype">bool</span> animal_is_animal = w.is(animal, animal); <span class="comment">// true</span></div>
<div class="line"><span class="keywordtype">bool</span> rabbit_is_animal = w.is(rabit, animal); <span class="comment">// true</span></div>
<div class="line"><span class="keywordtype">bool</span> wall_is_animal = w.is(wall, animal); <span class="comment">// false</span></div>
</div><!-- fragment --><p>The Is relation ship can be very helpful when used in queries. However, before this feature can be properly utilized, one needs to make sure the entity in the Is relationship is treated as a type (has a separate archetype).</p>
<div class="fragment"><div class="line"><span class="comment">// Iterate everything that is animal</span></div>
<div class="line">ecs::Query q = w.query().all(Pair(ecs::Is, animal));</div>
<div class="line">q.each([](ecs::Entity entity) {</div>
<div class="line">  <span class="comment">// entity = animal, rabbit</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Iterate everything that is animal but skip the &quot;animal&quot; itself</span></div>
<div class="line">ecs::Query q2 = w.query().all(Pair(ecs::Is, animal)).no(animal);</div>
<div class="line">q2.each([](ecs::Entity entity) {</div>
<div class="line">  <span class="comment">// entity = rabbit</span></div>
<div class="line">});</div>
</div><!-- fragment --><p>&gt;<b>NOTE:<br  />
</b> Currently inheritance works only for checking if something is something else. In the future, all ids that are present on the entity we inherit from will also be present on the inherited entity.</p>
<div class="fragment"><div class="line"><span class="comment">// NOT YET IMPLEMENTED, BUT THIS IS WHAT WILL HAPPEN IN THE FUTURE RELEASES.</span></div>
<div class="line"><span class="keyword">struct </span>Age { <span class="keywordtype">int</span> value; };</div>
<div class="line">...</div>
<div class="line">w.add&lt;Age&gt;(animal, {10});</div>
<div class="line"><span class="comment">// We did not add the Age component to hare but we added it to the entity it inherits from.</span></div>
<div class="line"><span class="comment">// Therefore, we can ask its age.</span></div>
<div class="line">Age age_hare = w.get&lt;Age&gt;(hare);</div>
<div class="line"><span class="comment">// We can decide to override the value with a custom one.</span></div>
<div class="line"><span class="comment">// This will only affect the hare entity (and any entity inheriting from it).</span></div>
<div class="line">w.set&lt;Age&gt;(hare, {20});</div>
<div class="line">Age age_animal = w.get&lt;Age&gt;(animal); <span class="comment">// age_animal.value is still equal to 10</span></div>
</div><!-- fragment --><h3><a class="anchor" id="cleanup-rules"></a>
Cleanup rules</h3>
<p>When deleting an entity we might want to define how the deletion is going to happen. Do we simply want to remove the entity or does everything connected to it need to get deleted as well? This behavior can be customized via relationships called cleanup rules.</p>
<p>Cleanup rules are defined as ecs::Pair(Condition, Reaction).</p>
<p>Condition is one of the following:</p><ul>
<li><em><b>OnDelete</b></em> - deleting an entity/pair</li>
<li><em><b>OnDeleteTarget</b></em> - deleting a pair's target</li>
</ul>
<p>Reaction is one of the following:</p><ul>
<li><em><b>Remove</b></em> - removes the entity/pair from anything referencing it</li>
<li><em><b>Delete</b></em> - delete everything referencing the entity</li>
<li><em><b>Error</b></em> - error out when deleted</li>
</ul>
<p>The default behavior of deleting an entity is to simply remove it from the parent entity. This is an equivalent of Pair(OnDelete, Remove) relationship pair attached to the entity getting deleted.</p>
<p>Additionally, a behavior which can not be changed, all relationship pairs formed by this entity need to be deleted as well. This is needed because entity ids are recycled internally and we could not guarantee that the relationship entity would be be used for something unrelated later.</p>
<p>All core entities are defined with (OnDelete,Error). This means that instead of deleting the entity an error is thrown when an attempt to delete the entity is made.</p>
<div class="fragment"><div class="line">ecs::Entity rabbit = w.add();</div>
<div class="line">ecs::Entity hare = w.add();</div>
<div class="line">ecs::Entity eats = w.add();</div>
<div class="line">ecs::Entity carrot = w.add();</div>
<div class="line">w.add(rabbit, ecs::Pair(eats, carrot));</div>
<div class="line">w.add(hare, ecs::Pair(eats, carrot));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Delete the rabbit. Everything else is unaffected.</span></div>
<div class="line">w.del(rabbit);</div>
<div class="line"><span class="comment">// Delete eats. Deletes eats and all associated relationships.</span></div>
<div class="line">w.del(eats); </div>
</div><!-- fragment --><p>Creating custom rules is just a matter of adding a relationship to an entity.</p>
<div class="fragment"><div class="line">ecs::Entity bomb_exploding_on_del = w.add();</div>
<div class="line">w.add(bomb_exploding_on_del, ecs::Pair(OnDelete, Delete));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Attach a bomb to our rabbit</span></div>
<div class="line">w.add(rabbit, bomb_exploding_on_del);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Deleting the bomb will take out all entities associated with it. Rabbit included.</span></div>
<div class="line">w.del(bomb_exploding_on_del); </div>
</div><!-- fragment --><p>A core entity <em><b>ChildOf</b></em> can be used to express a physical hierarchy. It uses the (OnDeleteTarget, Delete) relationship so if the parent is deleted, all its children are deleted as well.</p>
<div class="fragment"><div class="line">ecs::Entity parent = w.add();</div>
<div class="line">ecs::Entity child1 = w.add();</div>
<div class="line">ecs::Entity child2 = w.add();</div>
<div class="line">w.add(child1, ecs::Pair(ecs::ChildOf, parent));</div>
<div class="line">w.add(child2, ecs::Pair(ecs::ChildOf, parent));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Deleting parent deletes child1 and child2 as well.</span></div>
<div class="line">w.del(parent); </div>
</div><!-- fragment --><h2><a class="anchor" id="unique-components"></a>
Unique components</h2>
<p>Unique component is a special kind of data that exists at most once per chunk. In other words, you attach data to one chunk specifically. It survives entity removals and unlike generic components, they do not transfer to a new chunk along with their entity.</p>
<p>If you organize your data with care (which you should) this can save you some very precious memory or performance depending on your use case.</p>
<p>For instance, imagine you have a grid with fields of 100 meters squared. If you create your entities carefully they get organized in grid fields implicitly on the data level already without you having to use any sort of spatial map container.</p>
<div class="fragment"><div class="line">w.add&lt;Position&gt;(e1, {10,1});</div>
<div class="line">w.add&lt;Position&gt;(e2, {19,1});</div>
<div class="line"><span class="comment">// Make both e1 and e2 share a common grid position of {1,0}</span></div>
<div class="line">w.add&lt;ecs::uni&lt;GridPosition&gt;&gt;(e1, {1, 0});</div>
</div><!-- fragment --><h2><a class="anchor" id="delayed-execution"></a>
Delayed execution</h2>
<p>Sometimes you need to delay executing a part of the code for later. This can be achieved via command buffers.</p>
<p>Command buffer is a container used to record commands in the order in which they were requested at a later point in time.</p>
<p>Typically you use them when there is a need to perform structural changes (adding or removing an entity or component) while iterating queries.</p>
<p>Performing an unprotected structural change is undefined behavior and most likely crashes the program. However, using a command buffer you can collect all requests first and commit them when it is safe later.</p>
<p>You can use either a command buffer provided by the iterator or one you created. There are two kinds of the command buffer - <em><b>ecs::CommandBufferST</b></em> that is not thread-safe and should only be used by one thread, and <em><b>ecs::CommandBufferMT</b></em> that is safe to access from multiple threads at once.</p>
<p>The command buffer provided by the iterator is committed in a safe manner when the world is not locked for structural changes, and is a recommended way for queuing commands.</p>
<div class="fragment"><div class="line"><span class="comment">// Command buffer from the iterator. Commands are applied automatically when</span></div>
<div class="line"><span class="comment">// the iteration is over in a safe manner (takes into account other threads</span></div>
<div class="line"><span class="comment">// and only applies the changes when no ECS threads are doing changes).</span></div>
<div class="line"><span class="comment">// This is the recommended way for most use cases.</span></div>
<div class="line">ecs::Query q = w.query().all&lt;Position&gt;();</div>
<div class="line">q.each([&amp;](ecs::Iter&amp; it) {</div>
<div class="line">  ecs::CommandBufferST&amp; cb = it.cmd_buffer_st();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> vp = it.view&lt;Position&gt;();</div>
<div class="line">  GAIA_EACH(it) {</div>
<div class="line">    <span class="keywordflow">if</span> (p[i].y &lt; 0.0f) {</div>
<div class="line">       <span class="comment">// Queue entity e for deletion if its Y position falls below zero</span></div>
<div class="line">      cb.del(e);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"><span class="comment">// Once the world is ready, usually where iterations are finished, the changes are committed automatically.</span></div>
</div><!-- fragment --><p>With custom command buffer you need to manage things yourself. However, if might come handy in situations where things are fully under your control.</p>
<div class="fragment"><div class="line">ecs::World w;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Custom command buffer</span></div>
<div class="line">ecs::CommandBufferST cb(w);</div>
<div class="line">q.each([&amp;](Entity e, <span class="keyword">const</span> Position&amp; p) {</div>
<div class="line">  <span class="keywordflow">if</span> (p.y &lt; 0.0f) {</div>
<div class="line">    <span class="comment">// Queue entity e for deletion if its Y position falls below zero</span></div>
<div class="line">    cb.del(e);</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"><span class="comment">// Make the queued command happen</span></div>
<div class="line">cb.commit();</div>
</div><!-- fragment --><p>If you try to make an unprotected structural change with GAIA_DEBUG enabled (set by default when Debug configuration is used) the framework will assert letting you know you are using it the wrong way.</p>
<p>&gt;<b>NOTE:<br  />
</b> There is one situation to be wary about with command buffers. Function <em><b>add</b></em> accepting a component as template argument needs to make sure that the component is registered in the component cache. If it is not, it will be inserted. As a result, when used from multiple threads, both CommandBufferST and CommandBufferMT are a subject to race conditions. To avoid them, make sure that the component T has been registered in the world already. If you already added the component to some entity before, everything is fine. If you did not, you need to call this anywhere before you run your system or a query: </p><div class="fragment"><div class="line"><span class="comment">// Register the component YourComponent in the world</span></div>
<div class="line">world.add&lt;YourComponent&gt;();</div>
</div><!-- fragment --><p> &gt;Technically, template versions of functions <em><b>set</b></em> and <em><b>del</b></em> experience a similar issue. However, calling neither <em><b>set</b></em> nor <em><b>del</b></em> makes sense without a previous call to <em><b>add</b></em>. Such attempts are undefined behaviors (and reported by triggering an assertion).</p>
<h3><a class="anchor" id="command-merging-rules"></a>
Command Merging rules</h3>
<p>Before applying any operations to the world, the command buffer performs operation merging and cancellation to remove redundant or meaningless actions.</p>
<h4><a class="anchor" id="entity-merging"></a>
Entity Merging</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Sequence   </th><th class="markdownTableHeadNone">Result    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>add(e)</code> + <code>del(e)</code>   </td><td class="markdownTableBodyNone">No effect  entity never created    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>copy(src)</code> + <code>del(copy)</code>   </td><td class="markdownTableBodyNone">No effect  copy canceled    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>add(e)</code> + component ops + <code>del(e)</code>   </td><td class="markdownTableBodyNone">No effect  full chain canceled    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>del(e)</code> on an existing entity   </td><td class="markdownTableBodyNone">Entity removed normally   </td></tr>
</table>
<h4><a class="anchor" id="component-merging"></a>
Component Merging</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Sequence   </th><th class="markdownTableHeadNone">Result    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>add&lt;T&gt;(e)</code> + <code>set&lt;T&gt;(e, value)</code>   </td><td class="markdownTableBodyNone">Collapsed into <code>add&lt;T&gt;(e, value)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>add&lt;T&gt;(e, value1)</code> + <code>set&lt;T&gt;(e, value2)</code>   </td><td class="markdownTableBodyNone">Only the last value is used    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>add&lt;T&gt;(e)</code> + <code>del&lt;T&gt;(e)</code>   </td><td class="markdownTableBodyNone">No effect  component never added    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>add&lt;T&gt;(e, value)</code> + <code>del&lt;T&gt;(e)</code>   </td><td class="markdownTableBodyNone">No effect  component never added    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>set&lt;T&gt;(e, value1)</code> + <code>set&lt;T&gt;(e, value2)</code>   </td><td class="markdownTableBodyNone">Only the last value is used   </td></tr>
</table>
<p>Only the final state after all recorded operations is applied on commit. This means you can record commands freely, and the command buffer will merge your requests in such a way that the world update is always minimal and correct.</p>
<h2><a class="anchor" id="systems"></a>
Systems</h2>
<h3><a class="anchor" id="system-basics"></a>
System basics</h3>
<p>Systems are were your programs logic is executed. This usually means logic that is performed every frame / all the time. You can either spin your own mechanism for executing this logic or use the build-in one.</p>
<p>Creating a system is very similar to creating a <a class="el" href="index.html#query">query</a>. In fact, the built-in systems are queries internally. Ones which are performed at a later point in time. For each system an entity is created.</p>
<div class="fragment"><div class="line">SystemBuilder mySystem = w.system()</div>
<div class="line">  <span class="comment">// Set a name for the system (optional)</span></div>
<div class="line">  .name(<span class="stringliteral">&quot;PosAndVelSystem&quot;</span>)</div>
<div class="line">  <span class="comment">// System considers all entities with Position and Velocity components.</span></div>
<div class="line">  <span class="comment">// Position is mutable.</span></div>
<div class="line">  .all&lt;Position&amp;&gt;()</div>
<div class="line">  .all&lt;Velocity&gt;()</div>
<div class="line">  <span class="comment">// Logic to execute every time the system is invoked.</span></div>
<div class="line">  .on_each([&amp;sys1_cnt](Position&amp; p, <span class="keyword">const</span> Velocity&amp; v) {</div>
<div class="line">    p.x += v.x * dt;</div>
<div class="line">    p.y += v.y * dt;</div>
<div class="line">    p.z += v.z * dt;</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve the entity representing the system.</span></div>
<div class="line">Entity mySystemEntity = mySystem.entity();</div>
<div class="line"><span class="comment">// Disable the entity. This effectively disables the system.</span></div>
<div class="line">w.enable(mySystemEntity, <span class="keyword">false</span>);</div>
<div class="line"><span class="comment">// Enable the entity. This effectively makes the system runnable again.</span></div>
<div class="line">w.enable(mySystemEntity, <span class="keyword">true</span>);</div>
<div class="line"><span class="comment">// System is an entity. Therefore, it is easy to change its name at any point.</span></div>
<div class="line">w.name(<span class="stringliteral">&quot;MoveSystem&quot;</span>);</div>
</div><!-- fragment --><p>The system can be run manually or automatically.</p>
<div class="fragment"><div class="line"><span class="comment">// Run the system manually.</span></div>
<div class="line">mySystem.exec();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Call each system when the time is right.</span></div>
<div class="line">w.update();</div>
</div><!-- fragment --><p> Letting systems run via <b>World::update</b> automatically is the preferred way and what you would normally do. Gaia-ECS can resolve any dependencies and execute the systems in the right order.</p>
<h3><a class="anchor" id="system-dependencies"></a>
System dependencies</h3>
<p>By default, the order in which the systems are run depends on their entity id. The lower the id the earlier the system is executed. If a different order is needed, there are multiple ways to influence it.</p>
<p>One of them is adding the DependsOn relationship to a system's entity.</p>
<div class="fragment"><div class="line">SystemBuilder system1 = w.system().all ...</div>
<div class="line">SystemBuilder system2 = w.system().all ...</div>
<div class="line"><span class="comment">// Make system1 depend on system2. This way, system1 is always executed after system2.</span></div>
<div class="line">w.add(system1.entity(), ecs::Pair{DependsOn, system2});</div>
</div><!-- fragment --><p>If you need a specific group of systems depend on another group it can be achieved via the ChildOf relationship.</p>
<div class="fragment"><div class="line"><span class="comment">// Create 2 entities for system groups</span></div>
<div class="line">Entity group1 = w.add();</div>
<div class="line">Entity group2 = w.add();</div>
<div class="line"><span class="comment">// Create 3 systems</span></div>
<div class="line">SystemBuilder system1 = w.system().all ...</div>
<div class="line">SystemBuilder system2 = w.system().all ...</div>
<div class="line">SystemBuilder system3 = w.system().all ...</div>
<div class="line"><span class="comment">// System1 and System2 belong in group2.</span></div>
<div class="line"><span class="comment">// System3 belongs in group1.</span></div>
<div class="line"><span class="comment">// Therefore, system3 is executed first, followed by system1 and system2.</span></div>
<div class="line">w.add(system1.entity(), ecs::Pair{ChildOf, group2});</div>
<div class="line">w.add(system2.entity(), ecs::Pair{ChildOf, group2});</div>
<div class="line">w.add(system3.entity(), ecs::Pair{ChildOf, group1});</div>
</div><!-- fragment --><h3><a class="anchor" id="system-jobs"></a>
System jobs</h3>
<p>Systems support parallel execution and creating various job dependencies among them because they make use of the jobs internally. To learn more about jobs, navigate <a class="el" href="index.html#job-dependencies">here</a>. The logic is virtually the same as shown in the job dependencies example: </p><div class="fragment"><div class="line">SystemBuilder system1 = w.system().all ...</div>
<div class="line">SystemBuilder system2 = w.system().all ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get system job handles</span></div>
<div class="line">mt::JobHandle job1Handle = system1.job_handle();</div>
<div class="line">mt::JobHandle job2Handle = system2.job_handle();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create dependencies between systems</span></div>
<div class="line">tp.dep(job1Handle, job2Handle);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Submit jobs so worker threads can pick them up.</span></div>
<div class="line"><span class="comment">// The order in which jobs are submitted does not matter.</span></div>
<div class="line">tp.submit(job2Handle);</div>
<div class="line">tp.submit(job1Handle);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wait for the last job to complete.</span></div>
<div class="line">tp.wait(job1Handle);</div>
</div><!-- fragment --><p>Job handles created by the systems stay active until their system is deleted. Therefore, when managing system dependencies manually and their repeated use is wanted, job handles need to be refreshed before the next iteration: </p><div class="fragment"><div class="line">GAIA_FOR(1000) {</div>
<div class="line">  tp.submit(job2Handle);</div>
<div class="line">  tp.submit(job1Handle);</div>
<div class="line">  tp.wait(job1Handle);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Work is complete, let&#39;s prepare for the next iteration</span></div>
<div class="line">  tp.reset_state(job1handle);</div>
<div class="line">  tp.reset_state(job2handle);</div>
<div class="line">  tp.dep_refresh(job1Handle, job2Handle);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="data-layouts"></a>
Data layouts</h2>
<p>By default, all data inside components are treated as an array of structures (AoS). This is the natural behavior of the language and what you would normally expect.</p>
<p>Consider the following component:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Position {</div>
<div class="line">  <span class="keywordtype">float</span> x, y, z;</div>
<div class="line">};</div>
</div><!-- fragment --><p>If we imagine an ordinary array of 4 such Position components they are organized like this in memory: xyz xyz xyz xyz.</p>
<p>However, in specific cases, you might want to consider organizing your component's internal data as a structure or arrays (SoA): xxxx yyyy zzzz.</p>
<p>To achieve this you can tag the component with a GAIA_LAYOUT of your choosing. By default, GAIA_LAYOUT(AoS) is assumed.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Position {</div>
<div class="line">  GAIA_LAYOUT(SoA); <span class="comment">// Treat this component as SoA</span></div>
<div class="line">  <span class="keywordtype">float</span> x, y, z;</div>
<div class="line">};</div>
</div><!-- fragment --><p>If used correctly this can have vast performance implications. Not only do you organize your data in the most cache-friendly way this usually also means you can simplify your loops which in turn allows the compiler to optimize your code better.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PositionSoA {</div>
<div class="line">  GAIA_LAYOUT(SoA);</div>
<div class="line">  <span class="keywordtype">float</span> x, y, z;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>VelocitySoA {</div>
<div class="line">  GAIA_LAYOUT(SoA);</div>
<div class="line">  <span class="keywordtype">float</span> x, y, z;</div>
<div class="line">};</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">ecs::Query q = w.query()</div>
<div class="line">  .all&lt;PositionSoA&amp;&gt;()</div>
<div class="line">  .all&lt;VelocitySoA&gt;;</div>
<div class="line"> </div>
<div class="line">q.each([](ecs::Iter&amp; it) {</div>
<div class="line">  <span class="comment">// Position</span></div>
<div class="line">  <span class="keyword">auto</span> vp = it.view_mut&lt;PositionSoA&gt;(); <span class="comment">// read-write access to PositionSoA</span></div>
<div class="line">  <span class="keyword">auto</span> px = vp.set&lt;0&gt;(); <span class="comment">// continuous block of &quot;x&quot; from PositionSoA</span></div>
<div class="line">  <span class="keyword">auto</span> py = vp.set&lt;1&gt;(); <span class="comment">// continuous block of &quot;y&quot; from PositionSoA</span></div>
<div class="line">  <span class="keyword">auto</span> pz = vp.set&lt;2&gt;(); <span class="comment">// continuous block of &quot;z&quot; from PositionSoA</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Velocity</span></div>
<div class="line">  <span class="keyword">auto</span> vv = it.view&lt;VelocitySoA&gt;(); <span class="comment">// read-only access to VelocitySoA</span></div>
<div class="line">  <span class="keyword">auto</span> vx = vv.get&lt;0&gt;(); <span class="comment">// continuous block of &quot;x&quot; from VelocitySoA</span></div>
<div class="line">  <span class="keyword">auto</span> vy = vv.get&lt;1&gt;(); <span class="comment">// continuous block of &quot;y&quot; from VelocitySoA</span></div>
<div class="line">  <span class="keyword">auto</span> vz = vv.get&lt;2&gt;(); <span class="comment">// continuous block of &quot;z&quot; from VelocitySoA</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Handle x coordinates</span></div>
<div class="line">  GAIA_EACH(it) px[i] += vx[i] * dt;</div>
<div class="line">  <span class="comment">// Handle y coordinates</span></div>
<div class="line">  GAIA_EACH(it) py[i] += vy[i] * dt;</div>
<div class="line">  <span class="comment">// Handle z coordinates</span></div>
<div class="line">  GAIA_EACH(it) pz[i] += vz[i] * dt;</div>
<div class="line">});</div>
</div><!-- fragment --><p>You can even use SIMD intrinsics now without a worry. Note, this is just an example not an optimal way to rewrite the loop. Also, most compilers will auto-vectorize this code in release builds anyway. The code below uses x86 SIMD intrinsics:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">auto process_data = [](<span class="keywordtype">float</span>* p, <span class="keyword">const</span> <span class="keywordtype">float</span>* v, <span class="keyword">const</span> uint32_t cnt) {</div>
<div class="line">  uint32_t i = 0;</div>
<div class="line">  <span class="comment">// Process SSE-sized blocks first</span></div>
<div class="line">  <span class="keywordflow">for</span> (; i &lt; cnt; i+=4) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> pVec = _mm_load_ps(p + i);</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> vVec = _mm_load_ps(v + i);</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> respVec = _mm_fmadd_ps(vVec, dtVec, pVec);</div>
<div class="line">    _mm_store_ps(p + i, respVec);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Process the rest of the elements</span></div>
<div class="line">  <span class="keywordflow">for</span> (; i &lt; cnt; ++i) p[i] += v[i] * dt;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Handle x coordinates</span></div>
<div class="line">process_data(px.data(), vx.data(), it.size());</div>
<div class="line"><span class="comment">// Handle y coordinates</span></div>
<div class="line">process_data(py.data(), vy.data(), it.size());</div>
<div class="line"><span class="comment">// Handle z coordinates</span></div>
<div class="line">process_data(pz.data(), vz.data(), it.size());</div>
<div class="line">...</div>
</div><!-- fragment --><p>Different layouts use different memory alignments. <b>GAIA_LAYOUT(SoA)</b> and <b>GAIA_LAYOUT(AoS)</b> align data to 8-byte boundaries, while <b>GAIA_LAYOUT(SoA8)</b> and <b>GAIA_LAYOUT(SoA16)</b> align to 16 and 32 bytes respectively. This makes them a good candidate for AVX and AVX512 instruction sets (or their equivalent on different platforms, such as NEON on ARM).</p>
<h2><a class="anchor" id="serialization"></a>
Serialization</h2>
<p>Any data structure can be serialized into the provided serialization buffer. Native types, compound types, arrays, or any types exposing size(), begin() and end() functions are supported out of the box. If a resize() function is available, it will be used automatically. In some cases, you may still need to provide specializations, though. Either because the default behavior does not match your expectations, or because the program will not compile otherwise.</p>
<p>Serialization of arbitrary data is available in two different formats. One for compile-time serialization, and the other for runtime serialization. Their interface is the same.</p>
<h3><a class="anchor" id="compile-time-serialization"></a>
Compile-time serialization</h3>
<p>Compile-time serialization is available via following functions:</p><ul>
<li><em><b>ser::bytes</b></em> - calculates how many bytes the data needs to serialize</li>
<li><em><b>ser::save</b></em> - writes data to serialization buffer</li>
<li><em><b>ser::load</b></em> - loads data from serialization buffer</li>
</ul>
<p>It is not tied to ECS world and you can use it anywhere in your codebase.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Position {</div>
<div class="line">  <span class="keywordtype">float</span> x, y, z;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>Quaternion {</div>
<div class="line">  <span class="keywordtype">float</span> x, y, z, w;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>Transform {</div>
<div class="line">  Position p;</div>
<div class="line">  Quaternion r;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>TransformsContainer {</div>
<div class="line">  cnt::darray&lt;Transform&gt; transforms;</div>
<div class="line">  <span class="keywordtype">int</span> some_int_data;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">TransformsContainer in, out;</div>
<div class="line">GAIA_FOR(10) in.transforms.push_back({});</div>
<div class="line">in.some_int_data = 42069;</div>
<div class="line"> </div>
<div class="line">ser::ser_buffer_binary s;</div>
<div class="line"><span class="comment">// Save &quot;in&quot; to our buffer</span></div>
<div class="line">ser::save(s, in);</div>
<div class="line"><span class="comment">// Load the contents of buffer to &quot;out&quot; </span></div>
<div class="line">s.seek(0);</div>
<div class="line">ser::load(s, out);</div>
</div><!-- fragment --><p>Customization is possible for data types which require special attention. We can guide the serializer by either external or internal means.</p>
<p>External specialization comes handy in cases where we can not or do not want to modify the source type:</p>
<div class="fragment"><div class="line"><span class="comment">// A structure with two members variables we want to custom-serialize.</span></div>
<div class="line"><span class="comment">// We want to serialize ptr and size, and ignore foo.</span></div>
<div class="line"><span class="keyword">struct </span>CustomStruct {</div>
<div class="line">  std::string str;</div>
<div class="line">  <span class="keywordtype">bool</span> not_important;</div>
<div class="line">  <span class="keywordtype">int</span> foo;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>gaia::ser {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Serializer&gt;</div>
<div class="line">  <span class="keywordtype">void</span> tag_invoke(save_tag, Serializer&amp; s, <span class="keyword">const</span> CustomStruct&amp; data) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> lenInBytes = (uint64_t)data.str.size();</div>
<div class="line">    <span class="comment">// Save the byte size of our data</span></div>
<div class="line">    s.save(lenInBytes);</div>
<div class="line">    <span class="comment">// Save all data pointed to by ptr. Tell the serializer this &quot;char&quot; data</span></div>
<div class="line">    s.save_raw(data.str.data(), lenInBytes, ser::serialization_type_id::c8);</div>
<div class="line">    <span class="comment">// Save foo</span></div>
<div class="line">    s.save(data.foo);</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Serializer&gt;</div>
<div class="line">  <span class="keywordtype">void</span> tag_invoke(load_tag, Serializer&amp; s, CustomStruct&amp; data) {</div>
<div class="line">    uint64_t lenInBytes;</div>
<div class="line">    <span class="comment">// Load the byte size of our data</span></div>
<div class="line">    s.load(lengthInBytes);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Copy the string from our serialization buffer to std::string</span></div>
<div class="line">    data.str.assign(s.data(), lengthInBytes);</div>
<div class="line">    <span class="comment">// Explicitely tell the serializer to move by lengthInBytes because we only gave the std::string</span></div>
<div class="line">    <span class="comment">// a pointer and length. We did not read data any data from the buffer, so its head did not move.</span></div>
<div class="line">    s.seek(s.tell() + lengthInBytes);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Load foo</span></div>
<div class="line">    s.load(data.foo);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set not_important to some value. We did not save it, so we expect it to be set</span></div>
<div class="line">    <span class="comment">// externally at some point.</span></div>
<div class="line">    data.not_important = <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">CustomStruct in, out;</div>
<div class="line">in.str = <span class="stringliteral">&quot;gaia&quot;</span>;</div>
<div class="line"> </div>
<div class="line">ser::ser_buffer_binary s;</div>
<div class="line">ser::save(s, in);</div>
<div class="line"><span class="comment">// Move to the start of the buffer and load its contents to out</span></div>
<div class="line">s.seek(0);</div>
<div class="line">ser::load(s, out);</div>
<div class="line"><span class="comment">// Let&#39;s release the memory we allocated</span></div>
<div class="line"><span class="keyword">delete</span> in.ptr;</div>
<div class="line"><span class="keyword">delete</span> out.ptr;</div>
</div><!-- fragment --><p>You will usually use internal specialization when you have the access to your data container and at the same time do not want to expose its internal structure. Or if you simply like intrusive coding style better. In order to use it the following 3 member functions need to be provided:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>CustomStruct {</div>
<div class="line">  std::string str;</div>
<div class="line">  <span class="keywordtype">bool</span> not_important;</div>
<div class="line">  <span class="keywordtype">int</span> foo;</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Serializer&gt;</div>
<div class="line">  <span class="keywordtype">void</span> save(Serializer&amp; s)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> lenInBytes = (uint64_t)data.str.size();</div>
<div class="line">    s.save(lenInBytes);</div>
<div class="line">    s.save_raw(data.str.data(), lenInBytes, ser::serialization_type_id::c8);</div>
<div class="line">    s.save(data.foo);</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Serializer&gt;</div>
<div class="line">  <span class="keywordtype">void</span> load(Serializer&amp; s) {</div>
<div class="line">    uint64_t lenInBytes;</div>
<div class="line">    s.load(lengthInBytes);</div>
<div class="line">    data.str.assign(s.data(), lengthInBytes);</div>
<div class="line">    s.seek(s.tell() + lengthInBytes);</div>
<div class="line">    s.load(data.foo);</div>
<div class="line">    data.not_important = <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>It doesn't matter which kind of specialization you use. If both are used the external one takes priority.</p>
<h3><a class="anchor" id="runtime-serialization"></a>
Runtime serialization</h3>
<p>For runtime serialization you need to use the provided <em><b>ser::ISerializer</b></em> base and override the exposed virtual functions.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CustomBinarySerializer: <span class="keyword">public</span> ser::ISerializer {</div>
<div class="line">  ser::ser_buffer_binary m_buffer;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> align(uint32_t size, ser::serialization_type_id <span class="keywordtype">id</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> pos = m_buffer.tell();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> posAligned = mem::align(pos, ser::serialization_type_size(<span class="keywordtype">id</span>, size));</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> offset = posAligned - pos;</div>
<div class="line">    m_buffer.reserve(offset + size);</div>
<div class="line">    m_buffer.skip(offset);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> save_raw(<span class="keyword">const</span> <span class="keywordtype">void</span>* src, uint32_t size, ser::serialization_type_id <span class="keywordtype">id</span>)<span class="keyword"> override </span>{</div>
<div class="line">    align(size, <span class="keywordtype">id</span>);</div>
<div class="line">    m_buffer.save_raw((<span class="keyword">const</span> <span class="keywordtype">char</span>*)src, size, <span class="keywordtype">id</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> load_raw(<span class="keywordtype">void</span>* src, uint32_t size, ser::serialization_type_id <span class="keywordtype">id</span>)<span class="keyword"> override </span>{</div>
<div class="line">    align(size, <span class="keywordtype">id</span>);</div>
<div class="line">    m_buffer.load_raw((<span class="keywordtype">char</span>*)src, size, <span class="keywordtype">id</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* data()<span class="keyword"> const override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>*)m_buffer.data();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> reset()<span class="keyword"> override </span>{</div>
<div class="line">    m_buffer.reset();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  uint32_t tell()<span class="keyword"> const override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> m_buffer.tell();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  uint32_t bytes()<span class="keyword"> const override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> m_buffer.bytes();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> seek(uint32_t pos)<span class="keyword"> override </span>{</div>
<div class="line">    m_buffer.seek(pos);</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>This way you can create any serializer you want. For example, you can serialize your data to json or any other custom format you can imagine. You can give it support for versioning and so on.</p>
<p>Runtime serialization it tied to ECS world. You can hook it up via <em><b>World::set_serializer</b></em>.</p>
<div class="fragment"><div class="line">ecs::World world;</div>
<div class="line"><span class="comment">// Make the world use the custom serializer</span></div>
<div class="line">CustomBinarySerializer customSerializer;</div>
<div class="line">world.set_serializer(&amp;customSerializer);</div>
<div class="line"><span class="comment">// Make the world use the default serializer</span></div>
<div class="line">world.set_serializer(<span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p>Your serializer must remain valid for the entire time it is used by <em><b>ecs::World</b></em>. The world only stores a plain pointer to it. Therefore, if the serializer disappered and you forgot to call set_serializer(nullptr), the world would end up with a dangling pointer.</p>
<h3><a class="anchor" id="world-serialization"></a>
World serialization</h3>
<p>World serialization can be accessed via <em><b>World::save</b></em> and <em><b>World::load</b></em> functions.</p>
<div class="fragment"><div class="line"><span class="comment">// Save contents of our world into the current world serializer&#39;s buffer</span></div>
<div class="line">ecs::World world;</div>
<div class="line">world.save();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Load contents of the current world serializer&#39;s buffer into our world</span></div>
<div class="line">world.cleanup();</div>
<div class="line">world.load();</div>
</div><!-- fragment --><p>Note that for this feature to work correctly, components must be registered in a fixed order. If you called <em><b>World::save</b></em> and registered Position, Rotation, and Foo in that order, the same order must be used when calling <em><b>World::load</b></em>. This usually isnt an issue when loading data within the same program on the same world, but it matters when loading data saved by a different world or program.</p>
<div class="fragment"><div class="line">ecs::World world0;</div>
<div class="line"><span class="comment">// Register components</span></div>
<div class="line">(void)world0.add&lt;Position&gt;();</div>
<div class="line">(void)world0.add&lt;Rotation&gt;();</div>
<div class="line">(void)world0.add&lt;Foo&gt;();</div>
<div class="line"><span class="comment">// Save contents of our world into a buffer</span></div>
<div class="line">world0.save();</div>
<div class="line"> </div>
<div class="line">ecs::World world1;</div>
<div class="line"><span class="comment">// Register components</span></div>
<div class="line">(void)world1.add&lt;Position&gt;();</div>
<div class="line">(void)world1.add&lt;Rotation&gt;();</div>
<div class="line">(void)world1.add&lt;Foo&gt;();</div>
<div class="line"><span class="comment">// Load contents of a buffer into our second world</span></div>
<div class="line">world1.set_serializer(world0.get_serializer());</div>
<div class="line">world1.load();</div>
</div><!-- fragment --><h2><a class="anchor" id="multithreading"></a>
Multithreading</h2>
<h3><a class="anchor" id="jobs"></a>
Jobs</h3>
<p>To fully utilize your system's potential <b>Gaia-ECS</b> allows you to spread your tasks into multiple threads. This can be achieved in multiple ways.</p>
<p>Tasks that can not be split into multiple parts or it does not make sense for them to be split can use <em><b>ThreadPool::sched</b></em>. It registers a job in the job system and immediately submits it so worker threads can pick it up: </p><div class="fragment"><div class="line">mt::Job job0 {[]() {</div>
<div class="line">  InitializeScriptEngine();</div>
<div class="line">}};</div>
<div class="line">mt::Job job1 {[]() {</div>
<div class="line">  InitializeAudioEngine();</div>
<div class="line">}};</div>
<div class="line"> </div>
<div class="line">ThreadPool &amp;tp = ThreadPool::get();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Schedule jobs for parallel execution</span></div>
<div class="line">mt::JobHandle jobHandle0 = tp.sched(job0);</div>
<div class="line">mt::JobHandle jobHandle1 = tp.sched(job1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wait for jobs to complete</span></div>
<div class="line">tp.wait(jobHandle0);</div>
<div class="line">tp.wait(jobHandle1);</div>
</div><!-- fragment --><p>When crunching larger data sets it is often beneficial to split the load among threads automatically. This is what <em><b>ThreadPool::sched_par</b></em> is for.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> uint32_t SumNumbers(<a class="code hl_class" href="classgaia_1_1core_1_1span.html">std::span&lt;const uint32_t&gt;</a> arr) {</div>
<div class="line">  uint32_t sum = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (uint32_t val: arr)</div>
<div class="line">    sum += val;</div>
<div class="line">  <span class="keywordflow">return</span> sum;</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">constexpr uint32_t N = 1&#39;000&#39;000;</div>
<div class="line">cnt::darray&lt;uint32_t&gt; arr;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">std::atomic_uint32_t sum = 0;</div>
<div class="line">mt::JobParallel job {[&amp;arr, &amp;sum](<span class="keyword">const</span> mt::JobArgs&amp; args) {</div>
<div class="line">  sum += SumNumbers({arr.data() + args.idxStart, args.idxEnd - args.idxStart});</div>
<div class="line">  }};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Schedule multiple jobs to run in parallel. Make each job process up to 1234 items.</span></div>
<div class="line">mt::JobHandle jobHandle = tp.sched_par(job, N, 1234);</div>
<div class="line"><span class="comment">// Alternatively, we can tell the job system to figure out the group size on its own</span></div>
<div class="line"><span class="comment">// by simply omitting the group size or using 0:</span></div>
<div class="line"><span class="comment">// mt::JobHandle jobHandle = tp.sched_par(job, N);</span></div>
<div class="line"><span class="comment">// mt::JobHandle jobHandle = tp.sched_par(job, N, 0);</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wait for jobs to complete</span></div>
<div class="line">tp.wait(jobHandle);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use the result</span></div>
<div class="line">GAIA_LOG(<span class="stringliteral">&quot;Sum: %u\n&quot;</span>, sum);</div>
<div class="ttc" id="aclassgaia_1_1core_1_1span_html"><div class="ttname"><a href="classgaia_1_1core_1_1span.html">gaia::core::span</a></div><div class="ttdef"><b>Definition</b> span_impl.h:99</div></div>
</div><!-- fragment --><h3><a class="anchor" id="job-dependencies"></a>
Job dependencies</h3>
<p>Sometimes we need to wait for the result of another operation before we can proceed. To achieve this we need to use low-level API and handle job registration and submitting jobs on our own. &gt;<b>NOTE:<br  />
</b> This is because once submitted we can not modify the job anymore. If we could, dependencies would not necessary be adhered to.<br  />
 Let us say there is a job A that depends on job B. If job A is submitted before creating the dependency, a worker thread could execute the job before the dependency is created. As a result, the dependency would not be respected and job A would be free to finish before job B.</p>
<div class="fragment"><div class="line">mt::Job job0;</div>
<div class="line">job0.func = [&amp;arr, i]() {</div>
<div class="line">  arr[i] = i;</div>
<div class="line">};</div>
<div class="line">mt::Job job1;</div>
<div class="line">job1.func = [&amp;arr, i]() {</div>
<div class="line">  arr[i] *= i;</div>
<div class="line">};</div>
<div class="line">mt::Job job2;</div>
<div class="line">job2.func = [&amp;arr, i]() {</div>
<div class="line">  arr[i] += i;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register our jobs in the job system</span></div>
<div class="line"><span class="keyword">auto</span> job0Handle = tp.add(job0);</div>
<div class="line"><span class="keyword">auto</span> job1Handle = tp.add(job1);</div>
<div class="line"><span class="keyword">auto</span> job2Handle = tp.add(job2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create dependencies</span></div>
<div class="line">tp.dep(job0Handle, job1Handle);</div>
<div class="line">tp.dep(job1Handle, job2Handle);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Submit jobs so worker threads can pick them up.</span></div>
<div class="line"><span class="comment">// The order in which jobs are submitted does not matter.</span></div>
<div class="line">tp.submit(job2Handle);</div>
<div class="line">tp.submit(job1Handle);</div>
<div class="line">tp.submit(job0Handle);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wait for the last job to complete.</span></div>
<div class="line">tp.wait(job2Handle);</div>
</div><!-- fragment --><h3><a class="anchor" id="priorities"></a>
Priorities</h3>
<p>Nowadays, CPUs have multiple cores. Each of them is capable of running at different frequencies depending on the system's power-saving requirements and workload. Some CPUs contain cores designed to be used specifically in high-performance or efficiency scenarios. Or, some systems even have multiple CPUs.</p>
<p>Therefore, it is important to have the ability to utilize these CPU features with the right workload for our needs. Gaia-ECS allows jobs to be assigned a priority tag. You can either create a high-priority jobs (default) or low-priority ones.</p>
<p>The operating system should try to schedule the high-priority jobs to cores with highest level of performance (either performance cores, or cores with highest frequency etc.). Low-priority jobs are to target slowest cores (either efficiency cores, or cores with lowest frequency).</p>
<p>Where possible, the given system's QoS is utilized (Windows, MacOS). In case of operating systems based on Linux/FreeBSD that do not support QoS out-of-the-box, thread priorities are utilized.</p>
<p>Thread affinity is left untouched because this plays better with QoS and gives the operating system more control over scheduling.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a job designated for performance cores</span></div>
<div class="line">mt::Job job0;</div>
<div class="line">job0.priority = JobPriority::High;</div>
<div class="line">job0.func = ...;</div>
<div class="line">tp.sched(job0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a job designated for efficiency cores</span></div>
<div class="line">mt::Job job0;</div>
<div class="line">job0.priority = JobPriority::Low;</div>
<div class="line">job0.func = ...;</div>
<div class="line">tp.sched(job0);</div>
</div><!-- fragment --><h3><a class="anchor" id="job-behavior"></a>
Job behavior</h3>
<p>Job behavior can be partial customized. For example, if we want to manage its lifetime manually, on its creation we can tell the threadpool. </p><div class="fragment"><div class="line">mt::Job job;</div>
<div class="line"><span class="comment">// This job&#39;s lifetime won&#39;t be managed by the threadpool</span></div>
<div class="line">job.flags = mt::JobCreationFlags::ManualDelete;</div>
<div class="line">tp.func = ...;</div>
<div class="line">mt::JobHandle handle = tp.sched(job);</div>
<div class="line">tp.wait(handle);</div>
<div class="line"><span class="comment">// We release the job handle ourselves</span></div>
<div class="line">tp.del(handle);</div>
</div><!-- fragment --><h3><a class="anchor" id="threads"></a>
Threads</h3>
<p>The total number of threads created for the pool is set via <em><b>ThreadPool::set_max_workers</b></em>. By default, the number of threads created is equal to the number of available CPU threads minus 1 (the main thread). However, no matter how many threads are requested, the final number if always capped to 31 (<em><b>ThreadPool::MaxWorkers</b></em>). The number of available threads on your hardware can be retrieved via <em><b>ThreadPool::hw_thread_cnt</b></em>.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; tp = mt::ThreadPool::get();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the number of hardware threads.</span></div>
<div class="line"><span class="keyword">const</span> uint32_t hwThreads = tp.hw_thread_cnt();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create &quot;hwThreads&quot; worker threads. Make all of them high priority workers.</span></div>
<div class="line">tp.set_max_workers(hwThreads, hwThreads);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create &quot;hwThreads&quot; worker threads. Make 1 of them a high priority worker.</span></div>
<div class="line"><span class="comment">// If more then 1 worker threads were created, the rest of them is dedicated</span></div>
<div class="line"><span class="comment">// for low-priority jobs.</span></div>
<div class="line">tp.set_max_workers(hwThreads, 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// No workers threads are used. If there were any before, they are destroyed.</span></div>
<div class="line"><span class="comment">// All processing is happening on the main thread.</span></div>
<div class="line">tp.set_max_workers(0, 0);</div>
</div><!-- fragment --><p>The number of worker threads for a given performance level can be adjusted via <em><b>ThreadPool::set_workers_high_prio</b></em> and <em><b>ThreadPool::set_workers_low_prio</b></em>. By default, all workers created are high-priority ones.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; tp = mt::ThreadPool::get();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the number of worker threads available for this system.</span></div>
<div class="line"><span class="keyword">const</span> uint32_t workers = tp.workers();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the number of worker threads dedicated for performance cores.</span></div>
<div class="line"><span class="comment">// E.g. if workers==5, this dedicates 4 worker threads for high-performance workloads</span></div>
<div class="line"><span class="comment">// and turns the remaining 1 into an efficiency worker.</span></div>
<div class="line">tp.set_workers_high_prio(workers - 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Make all workers high-performance ones.</span></div>
<div class="line">tp.set_workers_high_prio(workers);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the number of worker threads dedicated for efficiency cores.</span></div>
<div class="line"><span class="comment">// E.g. if workers==5, this dedicates 4 worker threads for efficiency workloads loads</span></div>
<div class="line"><span class="comment">// and turns the remaining 1 into a high-performance worker.</span></div>
<div class="line">tp.set_workers_low_prio(workers - 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Make all workers low-performance ones.</span></div>
<div class="line">tp.set_workers_low_prio(workers);</div>
</div><!-- fragment --><p>The main thread normally does not participate as a worker thread. However, if needed, it can join workers by calling <em><b>ThreadPool::update</b></em> from the main thread.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; tp = mt::ThreadPool::get();</div>
<div class="line"> </div>
<div class="line">ecs::World w1, w2;</div>
<div class="line"><span class="keywordflow">while</span> (!stopProgram) {</div>
<div class="line">  <span class="comment">// Create many jobs here</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Update both worlds</span></div>
<div class="line">  w1.update();</div>
<div class="line">  w2.update();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Help execute jobs on the main thread, too</span></div>
<div class="line">  tp.update();</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you need to designate a certain thread as the main thread, you can do it by calling <em><b>ThreadPool::make_main_thread</b></em> from that thread.</p>
<p>Note, the operating system has the last word here. It might decide to schedule low-priority threads to high-performance cores or high-priority threads to efficiency cores depending on how the scheduler decides it should be.</p>
<h2><a class="anchor" id="customization"></a>
Customization</h2>
<p>Certain aspects of the library can be customized.</p>
<h3><a class="anchor" id="logging"></a>
Logging</h3>
<p>All logging is handled via <b>GAIA_LOG_x</b> function. There are 4 logging levels: </p><div class="fragment"><div class="line">GAIA_LOG_D(<span class="stringliteral">&quot;This is a debug log&quot;</span>);</div>
<div class="line">GAIA_LOG_N(<span class="stringliteral">&quot;This is an info log&quot;</span>);</div>
<div class="line">GAIA_LOG_W(<span class="stringliteral">&quot;This is a warning log&quot;</span>);</div>
<div class="line"><span class="keywordtype">int</span> x = 0;</div>
<div class="line"><span class="keywordtype">float</span> f = 10.123f;</div>
<div class="line">GAIA_LOG_E(<span class="stringliteral">&quot;This is an error log. %d,%.2f&quot;</span>, x, f);</div>
</div><!-- fragment --><p>Overriding how logging behaves is possible via <em><b>util::set_log_func</b></em> and <em><b>util::set_log_line_func</b></em>. The first one overrides the entire gaia logging behavior. The second one keeps the internal logic intact, and only changes how logging a single line is handled.</p>
<p>To override the entire logging logic you can do: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyCustomLogger(util::LogLevel level, <span class="keyword">const</span> <span class="keywordtype">char</span>* fmt, va_list args) {</div>
<div class="line">  <span class="keywordtype">char</span> buf[2048];</div>
<div class="line">  vsnprintf(buf, <span class="keyword">sizeof</span>(buf), fmt, args);</div>
<div class="line">  <span class="comment">// Do whatever you want  e.g., forward to engine logger.</span></div>
<div class="line">  printf(<span class="stringliteral">&quot;[CUSTOM] %s\n&quot;</span>, buf);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">util::set_log_func(MyCustomLogger);</div>
<div class="line">GAIA_LOG_N(<span class="stringliteral">&quot;gaia-ecs&quot;</span>); <span class="comment">// this will use MyLineLogger</span></div>
<div class="line">util::set_log_func(<span class="keyword">nullptr</span>);</div>
<div class="line">GAIA_LOG_N(<span class="stringliteral">&quot;gaia-ecs&quot;</span>); <span class="comment">// this will use the default implementation</span></div>
</div><!-- fragment --><p>If you just want to handle formatted, null-terminated messages (the usual case) and do not want to worry about anything else: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyLineLogger(util::LogLevel level, <span class="keyword">const</span> <span class="keywordtype">char</span>* msg) {</div>
<div class="line">  <span class="comment">// Print a line-terminated message</span></div>
<div class="line">  printf(<span class="stringliteral">&quot;[CUSTOM LINE] %s\n&quot;</span>, msg);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">util::set_log_line_func(MyLineLogger);</div>
<div class="line">GAIA_LOG_N(<span class="stringliteral">&quot;gaia-ecs&quot;</span>); <span class="comment">// this will use MyLineLogger</span></div>
<div class="line">util::set_log_line_func(<span class="keyword">nullptr</span>);</div>
<div class="line">GAIA_LOG_N(<span class="stringliteral">&quot;gaia-ecs&quot;</span>); <span class="comment">// this will use the default implementation</span></div>
</div><!-- fragment --><p>Because you might want to commit all your logs only at a specific point in time you can also override the flushing behavior: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyLogFlusher(util::LogLevel level) {</div>
<div class="line">  fflush(stdout);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">util::set_log_flush_func(MyLogFlusher);</div>
<div class="line">util::log_flush(); <span class="comment">// this will use MyLogFlusher to flush flogs</span></div>
<div class="line">util::set_log_flush_func(<span class="keyword">nullptr</span>);</div>
<div class="line">util::log_flush(); <span class="comment">// this will use the default implementation</span></div>
</div><!-- fragment --><p>By default all loging is done directy to stdout (debug, info) or stderr (warning, error). No custom caching is implemented.</p>
<p>If this is undesired, and you want to use gaia-ecs also as a simple logging server, you can do so by invoking following commands before you start using the library: </p><div class="fragment"><div class="line">util::set_log_func(util::detail::log_cached);</div>
<div class="line">util::set_log_flush_func(util::detail::log_flush_cached);</div>
</div><!-- fragment --><p>Once called, all logs below the level of warning are going to be cached. They will be flushed either when the cache is full, when a warning or an error is logged, or when the flush is requested manually via <b>util::log_flush</b>.</p>
<p>The size of the cache can be controlled via preprocessor definitions <b>GAIA_LOG_BUFFER_SIZE</b> (how large logs can grow in bytes before flush is triggered) and <b>GAIA_LOG_BUFFER_ENTRIES</b> (how many log entries are possible before flush is triggered).</p>
<h1><a class="anchor" id="requirements"></a>
Requirements</h1>
<h2><a class="anchor" id="compiler"></a>
Compiler</h2>
<p>Compiler with a good support of C++17 is required.<br  />
 The project is <a href="https://github.com/richardbiely/gaia-ecs/actions/workflows/build.yml">continuously tested</a> and guaranteed to build warning-free on the following compilers:<br  />
</p><ul>
<li><a href="https://visualstudio.microsoft.com/">MSVC</a> 15 (Visual Studio 2017) or later<br  />
</li>
<li><a href="https://clang.llvm.org/">Clang</a> 7 or later<br  />
</li>
<li><a href="https://www.gnu.org/software/gcc/">GCC</a> 7 or later<br  />
</li>
</ul>
<h2><a class="anchor" id="dependencies"></a>
Dependencies</h2>
<p><a href="https://cmake.org">CMake</a> 3.12 or later is required to prepare the build. Other tools are officially not supported at the moment. However, nothing stops you from placing <a class="el" href="index.html#single-header">gaia.h</a> into your project.</p>
<p>Unit testing is handled via <a href="https://github.com/onqtam/doctest.git">doctest</a>. It can be controlled via -DGAIA_BUILD_UNITTEST=ON/OFF when configuring the project (OFF by default).</p>
<h1><a class="anchor" id="installation"></a>
Installation</h1>
<h2><a class="anchor" id="cmake"></a>
CMake</h2>
<p>The following shows the steps needed to build the library:</p>
<div class="fragment"><div class="line"># Check out the library</div>
<div class="line">git clone https://github.com/richardbiely/gaia-ecs.git</div>
<div class="line"># Go to the library root</div>
<div class="line">cd gaia-ecs</div>
<div class="line"># Make a build directory</div>
<div class="line">cmake -E make_directory &quot;build&quot;</div>
<div class="line"># Generate cmake build files (Release for Release configuration)</div>
<div class="line">cmake -DCMAKE_BUILD_TYPE=Release -S . -B &quot;build&quot;</div>
<div class="line"># ... or if you use CMake older than 3.13 you can do:</div>
<div class="line"># cmake -E chdir &quot;build&quot; cmake -DCMAKE_BUILD_TYPE=Release ../</div>
<div class="line"># Build the project</div>
<div class="line">cmake --build &quot;build&quot; --config Release</div>
</div><!-- fragment --><p>To target a specific build system you can use the <a href="https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html#manual:cmake-generators(7)"><em><b>-G</b></em> parameter</a>: </p><div class="fragment"><div class="line"># Microsoft Visual Studio 2022, 64-bit, x86 architecture </div>
<div class="line">cmake -G &quot;Visual Studio 17 2022&quot; -A x64 ...</div>
<div class="line"># Microsoft Visual Studio 2022, 64-bit, ARM architecture </div>
<div class="line">cmake -G &quot;Visual Studio 17 2022&quot; -A ARM64 ...</div>
<div class="line"># XCode</div>
<div class="line">cmake -G Xcode ...</div>
<div class="line"># Ninja</div>
<div class="line">cmake -G Ninja</div>
</div><!-- fragment --><p>&gt;<b>NOTE</b><br  />
 When using MacOS you might run into a few issues caused by the specifics of the platform unrelated to Gaia-ECS. Quick way to fix them is listed below. </p><blockquote class="doxtable">
<p>&zwj; CMake issue:<br  />
 After you update to a new version of Xcode you might start getting "Ignoring CMAKE_OSX_SYSROOT value: ..." warnings when building the project. Residual cmake cache is to blame here. A solution is to delete files generated by cmake.</p>
<p>Linker issue:<br  />
 When not building the project from Xcode and using <em><b>ld</b></em> as your linker, if XCode 15 or later is installed on your system you will most likely run into various issues: <a href="https://developer.apple.com/documentation/xcode-release-notes/xcode-15-release-notes#Linking">https://developer.apple.com/documentation/xcode-release-notes/xcode-15-release-notes#Linking</a>. In the CMake project a workaround is implemented which adds "-Wl,-ld_classic" to linker settings but if you use a different build system or settings you might want to do same. This workaround can be enabled via "-DGAIA_MACOS_BUILD_HACK=ON". </p>
</blockquote>
<p>To build the project using <b>Emscripten</b> you can do the following: </p><div class="fragment"><div class="line"># Generate cmake build files inside build-wasm directory</div>
<div class="line">emcmake cmake -S . -B build-wasm -DGAIA_BUILD_EXAMPLES=ON</div>
<div class="line"># Build the project</div>
<div class="line">cmake --build build-wasm/src/examples/example_wasm -j</div>
<div class="line"># Run the project inside the webbrowser.</div>
<div class="line">emrun --browser chrome --port 8080 --serve_root build-wasm/src/examples/example_wasm gaia_example_wasm.html</div>
</div><!-- fragment --><h3><a class="anchor" id="project-settings"></a>
Project settings</h3>
<p>Following is a list of parameters you can use to customize your build</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>GAIA_BUILD_UNITTEST</b>   </td><td class="markdownTableBodyNone">Builds the <a class="el" href="index.html#testing">unit test project</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>GAIA_BUILD_BENCHMARK</b>   </td><td class="markdownTableBodyNone">Builds the <a class="el" href="index.html#benchmarks">benchmark project</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>GAIA_BUILD_EXAMPLES</b>   </td><td class="markdownTableBodyNone">Builds <a class="el" href="index.html#examples">example projects</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>GAIA_GENERATE_CC</b>   </td><td class="markdownTableBodyNone">Generates <em><b>compile_commands.json</b></em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>GAIA_GENERATE_SINGLE_HEADER</b>   </td><td class="markdownTableBodyNone">Generates a <a class="el" href="index.html#single-header">single-header</a> version of the framework    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>GAIA_PROFILER_CPU</b>   </td><td class="markdownTableBodyNone">Enables CPU <a class="el" href="index.html#profiling">profiling</a> features    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>GAIA_PROFILER_MEM</b>   </td><td class="markdownTableBodyNone">Enabled memory <a class="el" href="index.html#profiling">profiling</a> features    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>GAIA_PROFILER_BUILD</b>   </td><td class="markdownTableBodyNone">Builds the <a class="el" href="index.html#profiling">profiler</a> (<a href="https://github.com/wolfpld/tracy">Tracy</a> by default)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>GAIA_USE_SANITIZER</b>   </td><td class="markdownTableBodyNone">Applies the specified set of <a class="el" href="index.html#sanitizers">sanitizers</a>   </td></tr>
</table>
<h3><a class="anchor" id="sanitizers"></a>
Sanitizers</h3>
<p>Possible options are listed in <a href="https://github.com/richardbiely/gaia-ecs/blob/main/cmake/sanitizers.cmake">cmake/sanitizers.cmake</a>.<br  />
 Note, that some options don't work together or might not be supported by all compilers. </p><div class="fragment"><div class="line">cmake -DCMAKE_BUILD_TYPE=Release -DGAIA_USE_SANITIZER=address -S . -B &quot;build&quot;</div>
</div><!-- fragment --><h3><a class="anchor" id="single-header"></a>
Single-header</h3>
<p><b>Gaia-ECS</b> is shipped also as a <a href="https://github.com/richardbiely/gaia-ecs/blob/main/single_include/gaia.h">single header file</a> which you can simply drop into your project and start using. To generate the header we use a wonderful Python tool <a href="https://github.com/Viatorus/quom">Quom</a>.</p>
<p>To generate the header use the following command inside your root directory. </p><div class="fragment"><div class="line">quom ./include/gaia.h ./single_include/gaia.h -I ./include</div>
</div><!-- fragment --><p>You can also use the attached make_single_header.sh or create your script for your platform.</p>
<p>Creation of the single header can be automated via -GAIA_GENERATE_SINGLE_HEADER.</p>
<h1><a class="anchor" id="repository-structure"></a>
Repository structure</h1>
<h2><a class="anchor" id="examples"></a>
Examples</h2>
<p>The repository contains some code examples for guidance.<br  />
 Examples are built if GAIA_BUILD_EXAMPLES is enabled when configuring the project (OFF by default).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Project name   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/richardbiely/gaia-ecs/tree/main/src/examples/example_external">External</a>   </td><td class="markdownTableBodyNone">A dummy example showing how to use the framework in an external project.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/richardbiely/gaia-ecs/tree/main/src/examples/example1">Standalone</a>   </td><td class="markdownTableBodyNone">A dummy example showing how to use the framework in a standalone project.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/richardbiely/gaia-ecs/tree/main/src/examples/app">DLL</a>   </td><td class="markdownTableBodyNone">A dummy example showing how to use the framework as a dynamic library that is used by an executable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/richardbiely/gaia-ecs/tree/main/src/examples/example2">Basic</a>   </td><td class="markdownTableBodyNone">Simple example using some basic features of the framework.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/richardbiely/gaia-ecs/tree/main/src/examples/example_roguelike">Roguelike</a>   </td><td class="markdownTableBodyNone">Roguelike game putting all parts of the framework to use and represents a complex example of how it is used in practice. It is work-in-progress and changes and evolves with the project.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/richardbiely/gaia-ecs/tree/main/src/examples/example_wasm">WASM</a>   </td><td class="markdownTableBodyNone">WebAssembly example that runs in the browser and now includes a lightweight Explorer-style UI for inspecting entities/components in real time.   </td></tr>
</table>
<p>&gt;<b>NOTE:</b> To build the WASM example with <b>Emscripten</b>: </p><div class="fragment"><div class="line">emcmake cmake -S . -B build-wasm -DGAIA_BUILD_EXAMPLES=ON</div>
<div class="line">cmake --build build-wasm/src/examples/example_wasm -j</div>
<div class="line">emrun --browser chrome --port 8080 --serve_root build-wasm/src/examples/example_wasm gaia_example_wasm.html</div>
</div><!-- fragment --><h2><a class="anchor" id="benchmarks"></a>
Benchmarks</h2>
<p>To be able to reason about the project's performance and prevent regressions benchmarks were created.</p>
<p>Benchmarking relies on <a href="https://github.com/iboB/picobench">picobench</a>. It can be controlled via -DGAIA_BUILD_BENCHMARK=ON/OFF when configuring the project (OFF by default).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Project name   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/richardbiely/gaia-ecs/tree/main/src/perf/duel">Duel</a>   </td><td class="markdownTableBodyNone">Compares various coding approaches  basic OOP with scattered heap data, OOP with allocators to control memory fragmentation, and different data-oriented designsagainst our ECS framework. Data-oriented performance (DOD) is the target we aim to match or approach, as it represents the fastest achievable level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/richardbiely/gaia-ecs/tree/main/src/perf/app">App</a>   </td><td class="markdownTableBodyNone">Somewhat similar to Duel but measures in a more complex scenario. Inspired by <a href="https://github.com/abeimler/ecs_benchmark">ECS benchmark</a>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/richardbiely/gaia-ecs/tree/main/src/perf/iter">Iteration</a>   </td><td class="markdownTableBodyNone">Covers iteration performance with different numbers of entities and archetypes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/richardbiely/gaia-ecs/tree/main/src/perf/entity">Entity</a>   </td><td class="markdownTableBodyNone">Focuses on performance of creating and removing entities and components of various sizes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/richardbiely/gaia-ecs/tree/main/src/perf/mt">Multithreading</a>   </td><td class="markdownTableBodyNone">Measures performance of the job system.   </td></tr>
</table>
<h2><a class="anchor" id="profiling"></a>
Profiling</h2>
<p>It is possible to measure the performance and memory usage of the framework via any 3rd party tool. However, support for <a href="https://github.com/wolfpld/tracy">Tracy</a> is added by default.</p>
<p><img src="tracy_1.png" alt="" class="inline" title="tracy_1"/>     <img src="tracy_2.png" alt="" class="inline" title="tracy_2"/>    </p>
<p>CPU part can be controlled via -DGAIA_PROF_CPU=ON/OFF (OFF by default).</p>
<p>Memory part can be controlled via -DGAIA_PROF_MEM=ON/OFF (OFF by default).</p>
<p>Building the profiler server can be controlled via -DGAIA_PROF_CPU=ON (OFF by default). &gt;<b>NOTE:<br  />
</b> This is a low-level feature mostly targeted for maintainers. However, if paired with your own profiler code it can become a very helpful tool.</p>
<p>Custom profiler support can be added by overriding GAIA_PROF_* preprocessor definitions: </p><div class="fragment"><div class="line"><span class="preprocessor">#define GAIA_PROF_FRAME my_profilers_frame_function</span></div>
<div class="line"><span class="preprocessor">#define GAIA_PROF_SCOPE my_profilers_zone_function</span></div>
<div class="line">...</div>
<div class="line">#include &lt;<a class="code hl_namespace" href="namespacegaia.html">gaia</a>.h&gt;</div>
<div class="ttc" id="anamespacegaia_html"><div class="ttname"><a href="namespacegaia.html">gaia</a></div><div class="ttdoc">Checks if endianess was detected correctly at compile-time.</div><div class="ttdef"><b>Definition</b> bitset.h:9</div></div>
</div><!-- fragment --><h2><a class="anchor" id="testing"></a>
Testing</h2>
<p>The project is thoroughly tested via thousands of unit tests covering essentially every feature of the framework. Benchmarking relies on <a href="https://github.com/iboB/picobench">picobench</a>.</p>
<p>It can be controlled via -DGAIA_BUILD_UNITTEST=ON/OFF (OFF by default).</p>
<h2><a class="anchor" id="documentation"></a>
Documentation</h2>
<p>The documentation is based on <a href="http://www.doxygen.nl">doxygen</a>. Building it manualy is controled via -DGAIA_GENERATE_DOCS=ON/OFF (OFF by default).</p>
<p>The API reference is created in HTML format in <code>your_build_directory/docs/html</code> directory.</p>
<p>The lastest version is always available <a href="https://richardbiely.github.io/gaia-ecs/">online</a>.</p>
<h1><a class="anchor" id="future"></a>
Future</h1>
<p>To see what the future holds for this project navigate <a href="https://github.com/users/richardbiely/projects/1/views/1">here</a></p>
<h1><a class="anchor" id="contributions"></a>
Contributions</h1>
<p>Requests for features, PRs, suggestions, and feedback are highly appreciated.</p>
<p>Make sure to visit the project's <a href="https://discord.gg/wJjK72yze2">discord</a> or the <a href="https://github.com/richardbiely/gaia-ecs/discussions">discussions section</a> here on GitHub. If necessary, you can contact me directly either via the e-mail (you can find it on my <a href="https://github.com/richardbiely">profile page</a>) or you can visit my <a href="https://www.x.com/richardbiely">X</a>.</p>
<p>If you find the project helpful, do not forget to leave a star. You can also support its development by becoming a <a href="https://www.github.com/sponsors/richardbiely">sponsor</a>, or making a donation via <a href="https://paypal.me/richardbiely">PayPal</a>.</p>
<p>Thank you for using the project. You rock! :)</p>
<h1><a class="anchor" id="license"></a>
License</h1>
<p>Code and documentation Copyright (c) 2021-2025 Richard Biely.</p>
<p>Code released under the <a href="https://github.com/richardbiely/gaia-ecs/blob/master/LICENSE">MIT license</a>.</p>
<div class="image">
<img src="logo_small.png" alt=""/>
<div class="caption">
gaia-ecs-small</div></div>
     </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
