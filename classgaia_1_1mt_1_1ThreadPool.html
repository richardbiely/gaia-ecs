<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gaia-ECS: gaia::mt::ThreadPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">Gaia-ECS<span id="projectnumber">&#160;v0.9.3</span>
   </div>
   <div id="projectbrief">A simple and powerful entity component system</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classgaia_1_1mt_1_1ThreadPool.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classgaia_1_1mt_1_1ThreadPool-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">gaia::mt::ThreadPool Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab8f242ce7bce79ca45c5bb9d5af8ee3d" id="r_ab8f242ce7bce79ca45c5bb9d5af8ee3d"><td class="memItemLeft" align="right" valign="top"><a id="ab8f242ce7bce79ca45c5bb9d5af8ee3d" name="ab8f242ce7bce79ca45c5bb9d5af8ee3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>make_main_thread</b> ()</td></tr>
<tr class="memdesc:ab8f242ce7bce79ca45c5bb9d5af8ee3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the calling thread the effective main thread from the thread pool perspective. <br /></td></tr>
<tr class="separator:ab8f242ce7bce79ca45c5bb9d5af8ee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34530603ddff9f01e0a04236f7e736d" id="r_ad34530603ddff9f01e0a04236f7e736d"><td class="memItemLeft" align="right" valign="top"><a id="ad34530603ddff9f01e0a04236f7e736d" name="ad34530603ddff9f01e0a04236f7e736d"></a>
GAIA_NODISCARD uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>workers</b> () const</td></tr>
<tr class="memdesc:ad34530603ddff9f01e0a04236f7e736d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of worker threads. <br /></td></tr>
<tr class="separator:ad34530603ddff9f01e0a04236f7e736d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6973cb5704fb43eee582498925ed3b4f" id="r_a6973cb5704fb43eee582498925ed3b4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#a6973cb5704fb43eee582498925ed3b4f">set_max_workers</a> (uint32_t count, uint32_t countHighPrio)</td></tr>
<tr class="memdesc:a6973cb5704fb43eee582498925ed3b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of workers for this system.  <br /></td></tr>
<tr class="separator:a6973cb5704fb43eee582498925ed3b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0223557ad9bf5f8fe05a5fd3794f2268" id="r_a0223557ad9bf5f8fe05a5fd3794f2268"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#a0223557ad9bf5f8fe05a5fd3794f2268">set_workers_high_prio_inter</a> (uint32_t &amp;workerIdx, uint32_t count)</td></tr>
<tr class="memdesc:a0223557ad9bf5f8fe05a5fd3794f2268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the number of worker threads participating at high priority workloads.  <br /></td></tr>
<tr class="separator:a0223557ad9bf5f8fe05a5fd3794f2268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2780b52b93906a41486ba7174a6d841" id="r_ae2780b52b93906a41486ba7174a6d841"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#ae2780b52b93906a41486ba7174a6d841">set_workers_low_prio_inter</a> (uint32_t &amp;workerIdx, uint32_t count)</td></tr>
<tr class="memdesc:ae2780b52b93906a41486ba7174a6d841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the number of worker threads participating at low priority workloads.  <br /></td></tr>
<tr class="separator:ae2780b52b93906a41486ba7174a6d841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf92b6607ea332bf40e6a2700a3223f4" id="r_acf92b6607ea332bf40e6a2700a3223f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#acf92b6607ea332bf40e6a2700a3223f4">set_workers_high_prio</a> (uint32_t count)</td></tr>
<tr class="memdesc:acf92b6607ea332bf40e6a2700a3223f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the number of worker threads participating at high priority workloads.  <br /></td></tr>
<tr class="separator:acf92b6607ea332bf40e6a2700a3223f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dfd17defbb8ef7890bc137f4bab873" id="r_ac1dfd17defbb8ef7890bc137f4bab873"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#ac1dfd17defbb8ef7890bc137f4bab873">set_workers_low_prio</a> (uint32_t count)</td></tr>
<tr class="memdesc:ac1dfd17defbb8ef7890bc137f4bab873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the number of worker threads participating at low priority workloads.  <br /></td></tr>
<tr class="separator:ac1dfd17defbb8ef7890bc137f4bab873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684585cca8c1be78e730e8681db6b34e" id="r_a684585cca8c1be78e730e8681db6b34e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#a684585cca8c1be78e730e8681db6b34e">dep</a> (<a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> jobFirst, <a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> jobSecond)</td></tr>
<tr class="memdesc:a684585cca8c1be78e730e8681db6b34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <em>jobSecond</em> depend on <em>jobFirst</em>. This means <em>jobSecond</em> will not run until <em>jobFirst</em> finishes.  <br /></td></tr>
<tr class="separator:a684585cca8c1be78e730e8681db6b34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b39ffc5339d878f52938789fc5df7b" id="r_ad6b39ffc5339d878f52938789fc5df7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#ad6b39ffc5339d878f52938789fc5df7b">dep</a> (<a class="el" href="classgaia_1_1core_1_1span.html">std::span</a>&lt; <a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> &gt; jobsFirst, <a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> jobSecond)</td></tr>
<tr class="memdesc:ad6b39ffc5339d878f52938789fc5df7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <em>jobSecond</em> depend on the jobs listed in <em>jobsFirst</em>. This means <em>jobSecond</em> will not run until all jobs from <em>jobsFirst</em> finish.  <br /></td></tr>
<tr class="separator:ad6b39ffc5339d878f52938789fc5df7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8275230ff1471e58c9922630c4b3ed0d" id="r_a8275230ff1471e58c9922630c4b3ed0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#a8275230ff1471e58c9922630c4b3ed0d">dep_refresh</a> (<a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> jobFirst, <a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> jobSecond)</td></tr>
<tr class="memdesc:a8275230ff1471e58c9922630c4b3ed0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <em>jobSecond</em> depend on <em>jobFirst</em>. This means <em>jobSecond</em> will not run until <em>jobFirst</em> finishes.  <br /></td></tr>
<tr class="separator:a8275230ff1471e58c9922630c4b3ed0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca40ef0d480aa0b72c97949d2d4aa50" id="r_a7ca40ef0d480aa0b72c97949d2d4aa50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#a7ca40ef0d480aa0b72c97949d2d4aa50">dep_refresh</a> (<a class="el" href="classgaia_1_1core_1_1span.html">std::span</a>&lt; <a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> &gt; jobsFirst, <a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> jobSecond)</td></tr>
<tr class="memdesc:a7ca40ef0d480aa0b72c97949d2d4aa50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <em>jobSecond</em> depend on the jobs listed in <em>jobsFirst</em>. This means <em>jobSecond</em> will not run until all jobs from <em>jobsFirst</em> finish.  <br /></td></tr>
<tr class="separator:a7ca40ef0d480aa0b72c97949d2d4aa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac071acb7130b43594f070629c0db9a5b" id="r_ac071acb7130b43594f070629c0db9a5b"><td class="memTemplParams" colspan="2">template&lt;typename TJob &gt; </td></tr>
<tr class="memitem:ac071acb7130b43594f070629c0db9a5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#ac071acb7130b43594f070629c0db9a5b">add</a> (TJob &amp;&amp;job)</td></tr>
<tr class="memdesc:ac071acb7130b43594f070629c0db9a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a threadpool job from <em>job</em>.  <br /></td></tr>
<tr class="separator:ac071acb7130b43594f070629c0db9a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a9c7911546ff9424636d4ea04762a3" id="r_ac9a9c7911546ff9424636d4ea04762a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#ac9a9c7911546ff9424636d4ea04762a3">del</a> (<a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> jobHandle)</td></tr>
<tr class="memdesc:ac9a9c7911546ff9424636d4ea04762a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a job handle <em>jobHandle</em> from the threadpool.  <br /></td></tr>
<tr class="separator:ac9a9c7911546ff9424636d4ea04762a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b18aa30cea5e815c01c0bc59682baba" id="r_a9b18aa30cea5e815c01c0bc59682baba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#a9b18aa30cea5e815c01c0bc59682baba">submit</a> (<a class="el" href="classgaia_1_1core_1_1span.html">std::span</a>&lt; <a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> &gt; jobHandles)</td></tr>
<tr class="memdesc:a9b18aa30cea5e815c01c0bc59682baba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes <em>jobHandles</em> into the internal queue so worker threads can pick them up and execute them. If there are more jobs than the queue can handle it puts the calling thread to sleep until workers consume enough jobs.  <br /></td></tr>
<tr class="separator:a9b18aa30cea5e815c01c0bc59682baba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbd23bad12f565645b15dde47918efb" id="r_a6bbd23bad12f565645b15dde47918efb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#a6bbd23bad12f565645b15dde47918efb">submit</a> (<a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> jobHandle)</td></tr>
<tr class="memdesc:a6bbd23bad12f565645b15dde47918efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes <em>jobHandle</em> into the internal queue so worker threads can pick it up and execute it. If there are more jobs than the queue can handle it puts the calling thread to sleep until workers consume enough jobs.  <br /></td></tr>
<tr class="separator:a6bbd23bad12f565645b15dde47918efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebeb058d1353577e3001789933a10b4" id="r_aaebeb058d1353577e3001789933a10b4"><td class="memItemLeft" align="right" valign="top"><a id="aaebeb058d1353577e3001789933a10b4" name="aaebeb058d1353577e3001789933a10b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset_state</b> (<a class="el" href="classgaia_1_1core_1_1span.html">std::span</a>&lt; <a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> &gt; jobHandles)</td></tr>
<tr class="separator:aaebeb058d1353577e3001789933a10b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b1dfd448e396fb6b7d368ba8896eae" id="r_a98b1dfd448e396fb6b7d368ba8896eae"><td class="memItemLeft" align="right" valign="top"><a id="a98b1dfd448e396fb6b7d368ba8896eae" name="a98b1dfd448e396fb6b7d368ba8896eae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset_state</b> (<a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> jobHandle)</td></tr>
<tr class="separator:a98b1dfd448e396fb6b7d368ba8896eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0a7d7790d17f4e46595805c623104d" id="r_a3b0a7d7790d17f4e46595805c623104d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#a3b0a7d7790d17f4e46595805c623104d">reset</a> (<a class="el" href="classgaia_1_1core_1_1span.html">std::span</a>&lt; <a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> &gt; jobHandles)</td></tr>
<tr class="memdesc:a3b0a7d7790d17f4e46595805c623104d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for <em>jobHandles</em> to finish and resets them to a reusable state.  <br /></td></tr>
<tr class="separator:a3b0a7d7790d17f4e46595805c623104d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7cd3e7684cfc8ff483a8b0efe93901" id="r_aca7cd3e7684cfc8ff483a8b0efe93901"><td class="memItemLeft" align="right" valign="top"><a id="aca7cd3e7684cfc8ff483a8b0efe93901" name="aca7cd3e7684cfc8ff483a8b0efe93901"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> (<a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> jobHandle)</td></tr>
<tr class="memdesc:aca7cd3e7684cfc8ff483a8b0efe93901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for <em>jobHandle</em> to finish and resets it to a reusable state. <br /></td></tr>
<tr class="separator:aca7cd3e7684cfc8ff483a8b0efe93901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d0fa10190a0bab62e90c57d7e76ddd" id="r_a53d0fa10190a0bab62e90c57d7e76ddd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#a53d0fa10190a0bab62e90c57d7e76ddd">sched</a> (<a class="el" href="structgaia_1_1mt_1_1Job.html">Job</a> &amp;job)</td></tr>
<tr class="memdesc:a53d0fa10190a0bab62e90c57d7e76ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a job to run on a worker thread.  <br /></td></tr>
<tr class="separator:a53d0fa10190a0bab62e90c57d7e76ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cab51f6b024770345cdf230054e80e5" id="r_a6cab51f6b024770345cdf230054e80e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#a6cab51f6b024770345cdf230054e80e5">sched</a> (<a class="el" href="structgaia_1_1mt_1_1Job.html">Job</a> &amp;job, <a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> dependsOn)</td></tr>
<tr class="memdesc:a6cab51f6b024770345cdf230054e80e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a job to run on a worker thread.  <br /></td></tr>
<tr class="separator:a6cab51f6b024770345cdf230054e80e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2766a133e553f291e229117ef4ff4e43" id="r_a2766a133e553f291e229117ef4ff4e43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#a2766a133e553f291e229117ef4ff4e43">sched_par</a> (<a class="el" href="structgaia_1_1mt_1_1JobParallel.html">JobParallel</a> &amp;job, uint32_t itemsToProcess, uint32_t groupSize)</td></tr>
<tr class="memdesc:a2766a133e553f291e229117ef4ff4e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a job to run on worker threads in parallel.  <br /></td></tr>
<tr class="separator:a2766a133e553f291e229117ef4ff4e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae2dc1ab79367b708af43dfa2cae810" id="r_abae2dc1ab79367b708af43dfa2cae810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#abae2dc1ab79367b708af43dfa2cae810">wait</a> (<a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> jobHandle)</td></tr>
<tr class="memdesc:abae2dc1ab79367b708af43dfa2cae810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until a job associated with the jobHandle finishes executing. Cleans up any job allocations and dependencies associated with <em>jobHandle</em> The calling thread participate in job processing until <em>jobHandle</em> is done.  <br /></td></tr>
<tr class="separator:abae2dc1ab79367b708af43dfa2cae810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208c24048e8b702dced46716d0c79ba3" id="r_a208c24048e8b702dced46716d0c79ba3"><td class="memItemLeft" align="right" valign="top"><a id="a208c24048e8b702dced46716d0c79ba3" name="a208c24048e8b702dced46716d0c79ba3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update</b> ()</td></tr>
<tr class="memdesc:a208c24048e8b702dced46716d0c79ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the main thread to help with jobs processing. <br /></td></tr>
<tr class="separator:a208c24048e8b702dced46716d0c79ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8915adfb194f3a0af9b89d1a7d82ddfc" id="r_a8915adfb194f3a0af9b89d1a7d82ddfc"><td class="memItemLeft" align="right" valign="top"><a id="a8915adfb194f3a0af9b89d1a7d82ddfc" name="a8915adfb194f3a0af9b89d1a7d82ddfc"></a>
static <a class="el" href="classgaia_1_1mt_1_1ThreadPool.html">ThreadPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> ()</td></tr>
<tr class="separator:a8915adfb194f3a0af9b89d1a7d82ddfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c4d24769c05292c533b2827f024cfe" id="r_af6c4d24769c05292c533b2827f024cfe"><td class="memItemLeft" align="right" valign="top">static GAIA_NODISCARD uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#af6c4d24769c05292c533b2827f024cfe">hw_thread_cnt</a> ()</td></tr>
<tr class="memdesc:af6c4d24769c05292c533b2827f024cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of HW threads available on the system. 1 is minimum.  <br /></td></tr>
<tr class="separator:af6c4d24769c05292c533b2827f024cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab247efbd1d071cf8788803558cd23e28" id="r_ab247efbd1d071cf8788803558cd23e28"><td class="memItemLeft" align="right" valign="top">static GAIA_NODISCARD uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#ab247efbd1d071cf8788803558cd23e28">hw_efficiency_cores_cnt</a> ()</td></tr>
<tr class="memdesc:ab247efbd1d071cf8788803558cd23e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of efficiency cores of the system.  <br /></td></tr>
<tr class="separator:ab247efbd1d071cf8788803558cd23e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a22d5e96819bc7c0bff8d135a21e67b42" id="r_a22d5e96819bc7c0bff8d135a21e67b42"><td class="memItemLeft" align="right" valign="top"><a id="a22d5e96819bc7c0bff8d135a21e67b42" name="a22d5e96819bc7c0bff8d135a21e67b42"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>JobManager</b></td></tr>
<tr class="separator:a22d5e96819bc7c0bff8d135a21e67b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac071acb7130b43594f070629c0db9a5b" name="ac071acb7130b43594f070629c0db9a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac071acb7130b43594f070629c0db9a5b">&#9670;&#160;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TJob &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> gaia::mt::ThreadPool::add </td>
          <td>(</td>
          <td class="paramtype">TJob &amp;&amp;&#160;</td>
          <td class="paramname"><em>job</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a threadpool job from <em>job</em>. </p>
<dl class="section warning"><dt>Warning</dt><dd>Must be used from the main thread. </dd>
<dd>
Can't be called while there are any jobs being executed. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structgaia_1_1mt_1_1Job.html">Job</a> handle of the scheduled job. </dd></dl>

</div>
</div>
<a id="ac9a9c7911546ff9424636d4ea04762a3" name="ac9a9c7911546ff9424636d4ea04762a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a9c7911546ff9424636d4ea04762a3">&#9670;&#160;</a></span>del()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::mt::ThreadPool::del </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a>&#160;</td>
          <td class="paramname"><em>jobHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes a job handle <em>jobHandle</em> from the threadpool. </p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="structgaia_1_1mt_1_1Job.html">Job</a> handle must not be used by any worker thread and can not be used by any active job handles as a dependency. </dd></dl>

</div>
</div>
<a id="a684585cca8c1be78e730e8681db6b34e" name="a684585cca8c1be78e730e8681db6b34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684585cca8c1be78e730e8681db6b34e">&#9670;&#160;</a></span>dep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::mt::ThreadPool::dep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a>&#160;</td>
          <td class="paramname"><em>jobFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a>&#160;</td>
          <td class="paramname"><em>jobSecond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes <em>jobSecond</em> depend on <em>jobFirst</em>. This means <em>jobSecond</em> will not run until <em>jobFirst</em> finishes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jobFirst</td><td>The job that must complete first. </td></tr>
    <tr><td class="paramname">jobSecond</td><td>The job that will run after <em>jobFirst</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This must be called before any of the listed jobs are scheduled. </dd></dl>

</div>
</div>
<a id="ad6b39ffc5339d878f52938789fc5df7b" name="ad6b39ffc5339d878f52938789fc5df7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b39ffc5339d878f52938789fc5df7b">&#9670;&#160;</a></span>dep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::mt::ThreadPool::dep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgaia_1_1core_1_1span.html">std::span</a>&lt; <a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> &gt;&#160;</td>
          <td class="paramname"><em>jobsFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a>&#160;</td>
          <td class="paramname"><em>jobSecond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes <em>jobSecond</em> depend on the jobs listed in <em>jobsFirst</em>. This means <em>jobSecond</em> will not run until all jobs from <em>jobsFirst</em> finish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jobsFirst</td><td>Jobs that must complete first. </td></tr>
    <tr><td class="paramname">jobSecond</td><td>The job that will run after <em>jobsFirst</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This must must to be called before any of the listed jobs are scheduled. </dd></dl>

</div>
</div>
<a id="a8275230ff1471e58c9922630c4b3ed0d" name="a8275230ff1471e58c9922630c4b3ed0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8275230ff1471e58c9922630c4b3ed0d">&#9670;&#160;</a></span>dep_refresh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::mt::ThreadPool::dep_refresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a>&#160;</td>
          <td class="paramname"><em>jobFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a>&#160;</td>
          <td class="paramname"><em>jobSecond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes <em>jobSecond</em> depend on <em>jobFirst</em>. This means <em>jobSecond</em> will not run until <em>jobFirst</em> finishes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jobFirst</td><td>The job that must complete first. </td></tr>
    <tr><td class="paramname">jobSecond</td><td>The job that will run after <em>jobFirst</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unlike <a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#a684585cca8c1be78e730e8681db6b34e" title="Makes jobSecond depend on jobFirst. This means jobSecond will not run until jobFirst finishes.">dep()</a> this function needs to be called when job handles are reused. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This must be called before any of the listed jobs are scheduled. </dd>
<dd>
This must be called from the main thread. </dd></dl>

</div>
</div>
<a id="a7ca40ef0d480aa0b72c97949d2d4aa50" name="a7ca40ef0d480aa0b72c97949d2d4aa50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca40ef0d480aa0b72c97949d2d4aa50">&#9670;&#160;</a></span>dep_refresh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::mt::ThreadPool::dep_refresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgaia_1_1core_1_1span.html">std::span</a>&lt; <a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> &gt;&#160;</td>
          <td class="paramname"><em>jobsFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a>&#160;</td>
          <td class="paramname"><em>jobSecond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes <em>jobSecond</em> depend on the jobs listed in <em>jobsFirst</em>. This means <em>jobSecond</em> will not run until all jobs from <em>jobsFirst</em> finish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jobsFirst</td><td>Jobs that must complete first. </td></tr>
    <tr><td class="paramname">jobSecond</td><td>The job that will run after <em>jobsFirst</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unlike <a class="el" href="classgaia_1_1mt_1_1ThreadPool.html#a684585cca8c1be78e730e8681db6b34e" title="Makes jobSecond depend on jobFirst. This means jobSecond will not run until jobFirst finishes.">dep()</a> this function needs to be called when job handles are reused. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This must be called before any of the listed jobs are scheduled. </dd>
<dd>
This must be called from the main thread. </dd></dl>

</div>
</div>
<a id="ab247efbd1d071cf8788803558cd23e28" name="ab247efbd1d071cf8788803558cd23e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab247efbd1d071cf8788803558cd23e28">&#9670;&#160;</a></span>hw_efficiency_cores_cnt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static GAIA_NODISCARD uint32_t gaia::mt::ThreadPool::hw_efficiency_cores_cnt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of efficiency cores of the system. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of efficiency cores. 0 if failed, or if there are no such cores. </dd></dl>

</div>
</div>
<a id="af6c4d24769c05292c533b2827f024cfe" name="af6c4d24769c05292c533b2827f024cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c4d24769c05292c533b2827f024cfe">&#9670;&#160;</a></span>hw_thread_cnt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static GAIA_NODISCARD uint32_t gaia::mt::ThreadPool::hw_thread_cnt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of HW threads available on the system. 1 is minimum. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of hardware threads or 1 if failed. </dd></dl>

</div>
</div>
<a id="a3b0a7d7790d17f4e46595805c623104d" name="a3b0a7d7790d17f4e46595805c623104d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0a7d7790d17f4e46595805c623104d">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::mt::ThreadPool::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgaia_1_1core_1_1span.html">std::span</a>&lt; <a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> &gt;&#160;</td>
          <td class="paramname"><em>jobHandles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for <em>jobHandles</em> to finish and resets them to a reusable state. </p>
<dl class="section warning"><dt>Warning</dt><dd>Handles that were auto-deleted (non-manual jobs) are skipped. </dd></dl>

</div>
</div>
<a id="a53d0fa10190a0bab62e90c57d7e76ddd" name="a53d0fa10190a0bab62e90c57d7e76ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d0fa10190a0bab62e90c57d7e76ddd">&#9670;&#160;</a></span>sched() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> gaia::mt::ThreadPool::sched </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgaia_1_1mt_1_1Job.html">Job</a> &amp;&#160;</td>
          <td class="paramname"><em>job</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedules a job to run on a worker thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">job</td><td><a class="el" href="structgaia_1_1mt_1_1Job.html">Job</a> descriptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Must be used from the main thread. </dd>
<dd>
Dependencies can't be modified for this job. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structgaia_1_1mt_1_1Job.html">Job</a> handle of the scheduled job. </dd></dl>

</div>
</div>
<a id="a6cab51f6b024770345cdf230054e80e5" name="a6cab51f6b024770345cdf230054e80e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cab51f6b024770345cdf230054e80e5">&#9670;&#160;</a></span>sched() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> gaia::mt::ThreadPool::sched </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgaia_1_1mt_1_1Job.html">Job</a> &amp;&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a>&#160;</td>
          <td class="paramname"><em>dependsOn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedules a job to run on a worker thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">job</td><td><a class="el" href="structgaia_1_1mt_1_1Job.html">Job</a> descriptor </td></tr>
    <tr><td class="paramname">dependsOn</td><td><a class="el" href="structgaia_1_1mt_1_1Job.html">Job</a> we depend on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Must be used from the main thread. </dd>
<dd>
Dependencies can't be modified for this job. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structgaia_1_1mt_1_1Job.html">Job</a> handle of the scheduled job. </dd></dl>

</div>
</div>
<a id="a2766a133e553f291e229117ef4ff4e43" name="a2766a133e553f291e229117ef4ff4e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2766a133e553f291e229117ef4ff4e43">&#9670;&#160;</a></span>sched_par()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> gaia::mt::ThreadPool::sched_par </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgaia_1_1mt_1_1JobParallel.html">JobParallel</a> &amp;&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itemsToProcess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>groupSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedules a job to run on worker threads in parallel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">job</td><td><a class="el" href="structgaia_1_1mt_1_1Job.html">Job</a> descriptor </td></tr>
    <tr><td class="paramname">itemsToProcess</td><td>Total number of work items </td></tr>
    <tr><td class="paramname">groupSize</td><td>Group size per created job. If zero the threadpool decides the group size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Must be used from the main thread. </dd>
<dd>
Dependencies can't be modified for this job. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structgaia_1_1mt_1_1Job.html">Job</a> handle of the scheduled batch of jobs. </dd></dl>

</div>
</div>
<a id="a6973cb5704fb43eee582498925ed3b4f" name="a6973cb5704fb43eee582498925ed3b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6973cb5704fb43eee582498925ed3b4f">&#9670;&#160;</a></span>set_max_workers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::mt::ThreadPool::set_max_workers </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>countHighPrio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of workers for this system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Requested number of worker threads to create. </td></tr>
    <tr><td class="paramname">countHighPrio</td><td>HighPrio Number of high-priority workers to create. Calculated as Max(count, countHighPrio). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>All jobs are finished first before threads are recreated. </dd></dl>

</div>
</div>
<a id="acf92b6607ea332bf40e6a2700a3223f4" name="acf92b6607ea332bf40e6a2700a3223f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf92b6607ea332bf40e6a2700a3223f4">&#9670;&#160;</a></span>set_workers_high_prio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::mt::ThreadPool::set_workers_high_prio </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the number of worker threads participating at high priority workloads. </p>
<dl class="section warning"><dt>Warning</dt><dd>All jobs are finished first before threads are recreated. </dd></dl>

</div>
</div>
<a id="a0223557ad9bf5f8fe05a5fd3794f2268" name="a0223557ad9bf5f8fe05a5fd3794f2268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0223557ad9bf5f8fe05a5fd3794f2268">&#9670;&#160;</a></span>set_workers_high_prio_inter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::mt::ThreadPool::set_workers_high_prio_inter </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>workerIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the number of worker threads participating at high priority workloads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">workerIdx</td><td>Number of high priority workers. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>Requested number of high priority workers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>All jobs are finished first before threads are recreated. </dd></dl>

</div>
</div>
<a id="ac1dfd17defbb8ef7890bc137f4bab873" name="ac1dfd17defbb8ef7890bc137f4bab873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1dfd17defbb8ef7890bc137f4bab873">&#9670;&#160;</a></span>set_workers_low_prio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::mt::ThreadPool::set_workers_low_prio </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the number of worker threads participating at low priority workloads. </p>
<dl class="section warning"><dt>Warning</dt><dd>All jobs are finished first before threads are recreated. </dd></dl>

</div>
</div>
<a id="ae2780b52b93906a41486ba7174a6d841" name="ae2780b52b93906a41486ba7174a6d841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2780b52b93906a41486ba7174a6d841">&#9670;&#160;</a></span>set_workers_low_prio_inter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::mt::ThreadPool::set_workers_low_prio_inter </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>workerIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the number of worker threads participating at low priority workloads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">workerIdx</td><td>Number of low priority workers. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>Requested number of low priority workers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>All jobs are finished first before threads are recreated. </dd></dl>

</div>
</div>
<a id="a6bbd23bad12f565645b15dde47918efb" name="a6bbd23bad12f565645b15dde47918efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bbd23bad12f565645b15dde47918efb">&#9670;&#160;</a></span>submit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::mt::ThreadPool::submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a>&#160;</td>
          <td class="paramname"><em>jobHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes <em>jobHandle</em> into the internal queue so worker threads can pick it up and execute it. If there are more jobs than the queue can handle it puts the calling thread to sleep until workers consume enough jobs. </p>
<dl class="section warning"><dt>Warning</dt><dd>Once submitted, dependencies can't be modified for this job. </dd></dl>

</div>
</div>
<a id="a9b18aa30cea5e815c01c0bc59682baba" name="a9b18aa30cea5e815c01c0bc59682baba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b18aa30cea5e815c01c0bc59682baba">&#9670;&#160;</a></span>submit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::mt::ThreadPool::submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgaia_1_1core_1_1span.html">std::span</a>&lt; <a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a> &gt;&#160;</td>
          <td class="paramname"><em>jobHandles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes <em>jobHandles</em> into the internal queue so worker threads can pick them up and execute them. If there are more jobs than the queue can handle it puts the calling thread to sleep until workers consume enough jobs. </p>
<dl class="section warning"><dt>Warning</dt><dd>Once submitted, dependencies can't be modified for this job. </dd></dl>

</div>
</div>
<a id="abae2dc1ab79367b708af43dfa2cae810" name="abae2dc1ab79367b708af43dfa2cae810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae2dc1ab79367b708af43dfa2cae810">&#9670;&#160;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::mt::ThreadPool::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgaia_1_1mt_1_1JobHandle.html">JobHandle</a>&#160;</td>
          <td class="paramname"><em>jobHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait until a job associated with the jobHandle finishes executing. Cleans up any job allocations and dependencies associated with <em>jobHandle</em> The calling thread participate in job processing until <em>jobHandle</em> is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jobHandle</td><td><a class="el" href="structgaia_1_1mt_1_1Job.html">Job</a> handle to wait for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/gaia-ecs/gaia-ecs/include/gaia/mt/<a class="el" href="threadpool_8h_source.html">threadpool.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegaia.html">gaia</a></li><li class="navelem"><b>mt</b></li><li class="navelem"><a class="el" href="classgaia_1_1mt_1_1ThreadPool.html">ThreadPool</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
